% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/main_analysis.R
\name{phyloscanner.analyse.trees}
\alias{phyloscanner.analyse.trees}
\alias{phyloscanner.analyse.tree}
\alias{phyloscanner.generate.blacklist}
\title{Perform a phyloscanner analysis on a tree or set of trees}
\usage{
phyloscanner.analyse.trees(
  tree.file.directory,
  tree.file.regex = "^RAxML_bestTree.InWindow_([0-9]+_to_[0-9]+)\\\\.tree$",
  splits.rule = c("s", "r", "f"),
  sankoff.k = 0,
  sankoff.unassigned.switch.threshold = 0,
  continuation.unassigned.proximity.cost = 1000,
  outgroup.name = NULL,
  multifurcation.threshold = -1,
  guess.multifurcation.threshold = F,
  user.blacklist.directory = NULL,
  user.blacklist.file.regex = NULL,
  duplicate.file.directory = NULL,
 
    duplicate.file.regex = "^DuplicateReadCountsProcessed_InWindow_([0-9]+_to_[0-9]+).csv$",
  recombination.file.directory = NULL,
  recombination.file.regex = "^RecombinantReads_InWindow_([0-9]+_to_[0-9]+).csv$",
  alignment.file.directory = NULL,
  alignment.file.regex = NULL,
  tip.regex = "^(.*)_read_([0-9]+)_count_([0-9]+)$",
  file.name.regex = "^(?:.*\\\\D)?([0-9]+)_to_([0-9]+).*$",
  seed = sample(1:1e+07, 1),
  norm.ref.file.name = NULL,
  norm.standardise.gag.pol = F,
  norm.constants = NULL,
  allow.mt = F,
  relaxed.ancestry = F,
  parsimony.blacklist.k = 0,
  raw.blacklist.threshold = 0,
  ratio.blacklist.threshold = 0,
  do.dual.blacklisting = F,
  max.reads.per.host = Inf,
  blacklist.underrepresented = F,
  min.reads.per.host = 1,
  min.tips.per.host = 1,
  use.ff = F,
  prune.blacklist = F,
  count.reads.in.parsimony = T,
  verbosity = 0,
  no.progress.bars = F
)

phyloscanner.analyse.tree(
  tree.file.name,
  splits.rule = c("s", "r", "f"),
  sankoff.k = 0,
  sankoff.unassigned.switch.threshold = 0,
  continuation.unassigned.proximity.cost = 1000,
  outgroup.name = NULL,
  multifurcation.threshold = -1,
  guess.multifurcation.threshold = F,
  user.blacklist.file.name = NULL,
  duplicate.file.name = NULL,
  recombination.file.name = NULL,
  alignment.file.name = NULL,
  tip.regex = "^(.*)_read_([0-9]+)_count_([0-9]+)$",
  file.name.regex = "^(?:.*\\\\D)?([0-9]+)_to_([0-9]+).*$",
  seed = sample(1:1e+07, 1),
  norm.ref.file.name = NULL,
  norm.standardise.gag.pol = F,
  norm.constants = NULL,
  allow.mt = F,
  relaxed.ancestry = F,
  parsimony.blacklist.k = 0,
  raw.blacklist.threshold = 0,
  ratio.blacklist.threshold = 0,
  do.dual.blacklisting = F,
  max.reads.per.host = Inf,
  blacklist.underrepresented = F,
  min.reads.per.host = 1,
  min.tips.per.host = 1,
  use.ff = F,
  prune.blacklist = F,
  count.reads.in.parsimony = T,
  verbosity = 0,
  no.progress.bars = F
)

phyloscanner.generate.blacklist(
  tree.file.directory,
  tree.file.regex = "^RAxML_bestTree.InWindow_([0-9]+_to_[0-9]+)\\\\.tree$",
  outgroup.name = NULL,
  multifurcation.threshold = -1,
  guess.multifurcation.threshold = F,
  user.blacklist.directory = NULL,
  user.blacklist.file.regex = NULL,
  duplicate.file.directory = NULL,
 
    duplicate.file.regex = "^DuplicateReadCountsProcessed_InWindow_([0-9]+_to_[0-9]+).csv$",
  alignment.file.directory = NULL,
  alignment.file.regex = NULL,
  tip.regex = "^(.*)_read_([0-9]+)_count_([0-9]+)$",
  file.name.regex = "^.*([0-9]+)_to_([0-9]+).*$",
  seed = sample(1:1e+07, 1),
  norm.ref.file.name = NULL,
  norm.standardise.gag.pol = F,
  norm.constants = NULL,
  parsimony.blacklist.k = 0,
  raw.blacklist.threshold = 0,
  ratio.blacklist.threshold = 0,
  do.dual.blacklisting = F,
  max.reads.per.host = Inf,
  blacklist.underrepresented = F,
  min.reads.per.host = 1,
  min.tips.per.host = 1,
  count.reads.in.parsimony = F,
  verbosity = 0
)
}
\arguments{
\item{tree.file.directory}{The directory containing all input trees.}

\item{tree.file.regex}{A regular expression identifying every file in \code{tree.file.directory} that is to be included in the analysis. The first capture group, if present, gives a unique string identifying each tree. If this is NULL then \code{phyloscanner} will attempt to open every file in \code{tree.file.directory}.}

\item{splits.rule}{The rules by which the sets of hosts are split into groups in order to ensure that all groups can be members of connected subgraphs without causing conflicts. Options: s=Sankoff with optional within-host diversity penalty (slow, rigorous, recommended), r=Romero-Severson (quick, less rigorous with >2 hosts), f=Sankoff with continuation costs (experimental).}

\item{sankoff.k}{For \code{splits.rule = s} or \code{f} only. The \emph{k} parameter in the Sankoff reconstruction, representing the within-host diversity penalty.}

\item{sankoff.unassigned.switch.threshold}{For \code{splits.rule = s} only. Threshold at which a lineage reconstructed as infecting a host will transition to the unassigned state, if it would be equally parsimonious to remain in that host.}

\item{continuation.unassigned.proximity.cost}{For \code{splits.rule = f} only. The branch length at which an node is reconstructed as unassigned if all its neighbouring nodes are a greater distance away. The default is 1000, intended to be effectively infinite, such a node will never normally receive the unassigned state.}

\item{outgroup.name}{The name of the tip in the phylogeny/phylogenies to be used as outgroup (if unspecified, trees will be assumed to be already rooted). This should be sufficiently distant to any sequence obtained from a host that it can be assumed that the MRCA of the entire tree was not a lineage present in any sampled individual.}

\item{multifurcation.threshold}{If specified, branches shorter than this in the input tree will be collapsed to form multifurcating internal nodes. This is recommended; many phylogenetics packages output binary trees with short or zero-length branches indicating multifurcations.}

\item{guess.multifurcation.threshold}{Whether to guess the multifurcation threshold from the branch lengths of the trees and the width of the genomic window (if that information is available). It is recommended that trees are examined by eye to check that they do appear to have multifurcations if using this option.}

\item{user.blacklist.directory}{An optional path for a folder containing pre-existing blacklist files. These tips are specified by the user to be excluded from the analysis.}

\item{user.blacklist.file.regex}{A regular expression identifying every file in \code{user.blacklist.directory} that contains a blacklist. If a capture group is specified then its contents will uniquely identify the tree it belongs to, which must matches the IDs found by \code{tree.file.regex}. If these IDs cannot be identified then matching will be attempted using genome window coordinates.}

\item{duplicate.file.directory}{An optional path for a folder containing information on duplicate reads, to be used for duplicate blacklisting. Normally this is produced by \code{phyloscanner_make_trees.py}.}

\item{duplicate.file.regex}{A regular expression identifying every file in \code{duplicate.file.directory} that contains a duplicates file. If a capture group is specified then its contents will uniquely identify the tree it belongs to, which must matches the IDs found by \code{tree.file.regex}. If these IDs cannot be identified then matching will be attempted using genome window coordinates.}

\item{recombination.file.directory}{An optional path for a folder containing results of the \code{phyloscanner_make_trees.py} recombination metric analysis.}

\item{recombination.file.regex}{A regular expression identifying every file in \code{recombination.file.directory} that contains a recombination file. If a capture group is specified then its contents will uniquely identify the tree it belongs to, which must matches the IDs found by \code{tree.file.regex}. If these IDs cannot be identified then matching will be attempted using genome window coordinates.}

\item{alignment.file.regex}{A regular expression identifying every file in \code{alignment.directory} that is an alignment. If a capture group is specified then its contents will uniquely identify the tree it belongs to, which must matches the IDs found by \code{tree.file.regex}. If these IDs cannot be identified then matching will be attempted using genome window coordinates.}

\item{tip.regex}{Regular expression identifying tips from the dataset. This expects up to three capture groups, for host ID, read ID, and read count (in that order). If the latter two groups are missing then read information will not be used. The default matches input from the phyloscanner pipeline where the host ID is the BAM file name.}

\item{file.name.regex}{Regular expression identifying window coordinates. Two capture groups: start and end; if the latter is missing then the first group is a single numerical identifier for the window. The default matches input from the phyloscanner pipeline.}

\item{seed}{Random number seed; used by the downsampling process, and also ties in some parsimony reconstructions can be broken randomly.}

\item{norm.ref.file.name}{Name of a file giving a normalisation constant for every genome position. Cannot be used simultaneously with \code{norm.constants}. If neither is given then no normalisation will be performed.}

\item{norm.standardise.gag.pol}{Use only if \code{norm.ref.file.name} is given. An HIV-specific option: if true, the normalising constants are standardised so that the average on gag+pol equals 1. Otherwise they are standardised so the average on the whole genome equals 1.}

\item{norm.constants}{Either the path of a CSV file listing the file name for each tree (column 1) and the respective normalisation constant (column 2) or a single numerical normalisation constant to be applied to every tree. Cannot be used simultaneously with \code{norm.ref.file.name}. If neither is given then no normalisation will be performed.}

\item{allow.mt}{If FALSE (the default0), directionality is only inferred between pairs of hosts where a single clade from one host is nested in one from the other; this is more conservative.}

\item{relaxed.ancestry}{If TRUE, then an ancestry call requires only that at least one subgraph from one host is descended from the other, and that there are no subgrapghs in the opposite arrangement. If TRUE (the default), then it requires that all subgraphs from one host are descended from one from the other.}

\item{parsimony.blacklist.k}{The \emph{k} parameter of the single-host Sankhoff parsimony reconstruction used to identify probable contaminants. A value of 0 is equivalent to not performing parsimony blacklisting.}

\item{raw.blacklist.threshold}{Used to specify a read count to be used as a raw threshold for duplicate or parsimony blacklisting. Use with \code{parsimony.blacklist.k} or \code{duplicate.file.regex} or both. Parsimony blacklisting will blacklist any subgraph with a read count strictly less than this threshold. Duplicate blacklisting will black list any duplicate read with a count strictly less than this threshold. The default value of 0 means nothing is blacklisted.}

\item{ratio.blacklist.threshold}{Used to specify a read count ratio (between 0 and 1) to be used as a threshold for duplicate or parsimony blacklisting. Use with \code{parsimony.blacklist.k} or \code{duplicate.file.regex} or both. Parsimony blacklisting will blacklist a subgraph if the ratio of its read count to the total read count from the same host is strictly less than this threshold. Duplcate blacklisting will blacklist a duplicate read if the ratio of its count to the count of the duplicate (from another host) is strictly less than this threshold.}

\item{do.dual.blacklisting}{Blacklist all reads from the minor subgraphs for all hosts established as dual by parsimony blacklisting (which must have been done for this to do anything).}

\item{max.reads.per.host}{Used to turn on downsampling. If given, tips will be blacklisted such that read counts (or tip counts if no read counts are identified) from each host are equal (although see \code{blacklist.underrepresented}).}

\item{blacklist.underrepresented}{If TRUE and \code{max.reads.per.host} is given, blacklist hosts from trees where their total tip count does not reach the maximum.}

\item{min.reads.per.host}{If given, hosts will be entirely blacklisted from a given tree if they have fewer than this number of reads on it (after all other blacklisting except downsampling).}

\item{min.tips.per.host}{If given, hosts will be entirely blacklisted from a given tree if they have fewer than this number of tips on it (after all other blacklisting except downsampling).}

\item{use.ff}{Use the \code{ff} package to store parsimony reconstruction matrices. Use if you run out of memory.}

\item{prune.blacklist}{If TRUE, all blacklisted and reference tips (except the outgroup) are pruned away before starting parsimony-based reconstruction.}

\item{count.reads.in.parsimony}{If TRUE, read counts on tips will be taken into account in parsimony reconstructions at the parents of zero-length terminal branches. Not applicable for the Romero-Severson-like reconstruction method.}

\item{verbosity}{The type of verbose output. 0=none, 1=minimal, 2=complete}

\item{no.progress.bars}{Hide the progress bars from verbose output.}

\item{tree.file.name}{The name of a single tree file (Newick or NEXUS format).}

\item{user.blacklist.file.name}{The path of a single text file containing the user-specified list of tips to be blacklisted}

\item{duplicate.file.name}{The path of a single \code{.csv} file specifying which tree tips are from duplicate reads. Normally this is produced by \code{phyloscanner_make_trees.py}.}

\item{recombination.file.name}{The path for a single file containing the results of the \code{phyloscanner_make_trees.py} recombination metric analysis.}

\item{alignment.directory}{The directory containing the alignments used to construct the phylogenies.}
}
\value{
A list of class \code{phyloscanner.trees}. Each element of this list is itself a list of class \code{phyloscanner.tree} and corresponds to a single tree, recording details of the \code{phyloscanner} reconstruction. The \code{names} of the \code{phyloscanner.trees} object are the tree IDs, usually derived from file suffixes. A list of class \code{phyloscanner.tree} may, depending on exact circumstances, have the following items:
\itemize{
\item{\code{id}}{ The tree ID.}
\item{\code{tree}}{ The tree as a \code{phylo} object. This will have been rooted and have multifurcations collapsed as requested, but branch lengths are original. It may have been pruned of blacklisted tips if \code{prune.blacklist} was specified.}
\item{\code{alignment}}{ The alignment as a \code{DNAbin} object.}
\item{\code{tree.file.name}}{ The file name from which the tree was loaded.}
\item{\code{alignment.file.name}}{ The file name for the alignment.}
\item{\code{user.blacklist.file.name}}{ The file name for the user-specified blacklist.}
\item{\code{duplicate.file.name}}{ The file name for the list of between-host duplicate tips.}
\item{\code{recombination.file.name}}{ The file name for the results of the \code{phyloscanner_make_trees.py} recombination metric analysis.}
\item{\code{index}}{ The index of this tree in the \code{phyloscanner.trees} list.}
\item{\code{bl.report}}{ A \code{data.frame} outlining the blacklisted tips in this tree and the reasons they were blacklisted.}
\item{\code{window.coords}}{ A vector giving the start and end of the genome cooardinates of the window from which the tree was built (if the windowed approach was used).}
\item{\code{xcoord}}{ A single genome position to locate this tree along the genome; generally the window midpoint in the windowed approach.}
\item{\code{duplicate.file.name}}{ The file name used to determine between-host duplicate tips}
\item{\code{original.tip.labels}}{ Blacklisting may lead to the pruinig of tips from the tree or their renaming. The original tip labels read from the tree file are recorded here.}
\item{\code{hosts.for.tips}}{ A vector mapping each tip onto its correspoinding hosts. Blacklisted tips are given NA.}
\item{\code{normalisation.constant}}{ The normalisation constant for this tree. This will be 1 if no normalisation was requested.}
\item{\code{duplicate.tips}}{ A list whose entries are vectors of tips whose sequences are exactly alike.}
\item{\code{blacklist}}{ A vector of numbers for all tips blacklisted for whatever reason. If the blacklist was pruned away, this will be empty.}
\item{\code{dual.detection.splits}}{ A \code{data.frame} determining the multiplicity of infection for each host as determined by parsimony blacklisting.}
\item{\code{duals.info}}{ A \code{data.frame} describing the subgraphs that each tip belong to in the dual infection detection, prior to parsimony and dual blacklisting.}
\item{\code{tips.for.hosts}}{ A list giving the tips numbers corresponding to each host}
\item{\code{read.counts}}{ A vector giving the read counts for each tip. Blacklisted tips and the outgroup have NAs. All non-NAs will be 1 if the data has no read count.}
\item{\code{splits.table}}{ A data frame giving the host and subgraph containing each tip, according to the parsimony reconstruction.}
\item{\code{clades.by.host}} {A list of lists of tips, each determining a monophyletic clade from one host.}
\item{\code{clade.mrcas.by.host}}{ A list of vectors containing the MRCA nodes of those clades.}
\item{\code{classification.results}}{ A \code{data.frame} desribing the pairwise topological classification of each pair of hosts in the tree.}
}
A \code{phyloscanner.trees} object has the following attributes:
\itemize{
\item{\code{readable.coords}}{ TRUE if genome window coordinates could be obtained from file names.}
\item{\code{match.mode}}{ Either "ID" (tree IDs were identified using \code{tree.file.regex}), "coords" (tree IDs were identified from what appear to be genome window coordinates in file names) or "none" (string IDs could not be determined).}
\item{\code{has.read.counts}}{ TRUE if \code{phyloscanner} detected read counts in tip labels.}
\item{\code{outgroup.name}}{ The tip label of the outgroup.}
}
}
\description{
These functions perform a parsimony reconstruction and classification of pairwise host relationships.
}
\details{
\code{phyloscanner.analyse.tree} is for a single phylogeny and \code{phyloscanner.analyse.trees} for a collection, while \code{phyloscanner.generate.blacklist} performs the blacklisting steps only.
}
\examples{
#
# Example on data from Rakai Community Cohort Study
#
\dontrun{

require(phyloscannerR)

#	extract RCCS example data
tree.file.zip <- system.file(file.path('extdata','Rakai_run192_trees.zip'),package='phyloscannerR')
tree.file.directory <- tempdir()	
unzip(tree.file.zip, exdir=tree.file.directory, junkpaths=TRUE)
	
#	arguments used for RCCS analysis
file.name.regex <- "^\\D*([0-9]+)_to_([0-9]+)\\D*$"
max.reads.per.host <- 50
multifurcation.threshold <- 1e-5
norm.ref.file.name <- system.file('HIV_DistanceNormalisationOverGenome.csv',package='phyloscannerR')	
outgroup.name <- "REF_CPX_AF460972"
raw.blacklist.threshold <- 20
sankoff.k <- 20
sankoff.unassigned.switch.threshold <- 0
seed <- 42
splits.rule <- 's'
relaxed.ancestry <- TRUE
allow.mt <- TRUE
tip.regex <- "^(.*)_fq[0-9]+_read_([0-9]+)_count_([0-9]+)$"
tree.file.regex <- "^ptyr192_InWindow_([0-9]+_to_[0-9]+)\\.tree$"
verbosity <- 1

#	analyse deep sequence trees
phsc <- phyloscanner.analyse.trees(tree.file.directory,
             allow.mt=allow.mt,
             alignment.file.directory = NULL, 
             alignment.file.regex = NULL,
             blacklist.underrepresented = FALSE,
             count.reads.in.parsimony = TRUE,
             do.dual.blacklisting = FALSE,
             duplicate.file.directory = NULL,
             duplicate.file.regex = NULL,
             file.name.regex = file.name.regex,
             guess.multifurcation.threshold = FALSE,
             max.reads.per.host = max.reads.per.host,
             multifurcation.threshold = multifurcation.threshold,
             norm.constants = NULL,
             norm.ref.file.name = NULL,
             norm.standardise.gag.pol = TRUE,
             no.progress.bars = FALSE,
             outgroup.name = outgroup.name,
             parsimony.blacklist.k = sankoff.k,
             prune.blacklist = FALSE,
             ratio.blacklist.threshold = 0, 
             raw.blacklist.threshold = raw.blacklist.threshold,			
             recombination.file.directory = NULL,
             recombination.file.regex = NULL,
             relaxed.ancestry = relaxed.ancestry,
             sankoff.k = sankoff.k,
             sankoff.unassigned.switch.threshold = sankoff.unassigned.switch.threshold,
             seed = seed,
             splits.rule = splits.rule,
             tip.regex = tip.regex,
             tree.file.regex = tree.file.regex,
             use.ff = FALSE,
             user.blacklist.directory = NULL, 
             user.blacklist.file.regex = NULL,
             verbosity = verbosity 
             )
}
}
\seealso{
\code{\link{find.pairs.in.networks}}, \code{\link{find.networks}}
}
