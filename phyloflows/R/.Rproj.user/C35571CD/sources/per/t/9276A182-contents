---
title: "Source attribution under GLM"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

We start by simulating data required for this task. 'dg' is a data table containing the number of individuals who are eligible (**TRIAL**) and sampled (**SUC**) and covraites for each subpopulation (**CATEGORY**). Assume there are two locations where the numbers of infected individuals are 120 and 80. 

Now we generate covariates for individuals (gender and age). Assume 70% infected individuals are women in group 1, among which 25%, 60% and 15% are aged 15-24, 25-34 and 35+; among men in group 1, 20%, 50% and 30% are aged 15-24, 25-34 and 35+. Assume 60% infected individuals are women in group 1, among which 25%, 50% and 25% are aged 15-24, 25-34 and 35+; among men in group 1, 20%, 40% and 40% are aged 15-24, 25-34 and 35+. 

```{r} 
library(data.table)
library(Boom)
library(TransSubpopulation)
set.seed(123)
dg<-data.table(COMM_NUM_B=c(rep(1,120),rep(2,80)),INF=rep(1,200))
num.f.1<-round(120*0.7)
num.m.1<-120-round(120*0.7)
num.f.2<-round(80*0.6)
num.m.2<-80-round(80*0.6)

dg$SEX<-c(rep('F',num.f.1),
          rep('M',num.m.1),
          rep('F',num.f.2),
          rep('M',num.m.2))
dg$AGE_AT_MID_C<-c(rep('15-24',round(num.f.1*0.25)),
                   rep('25-34',round(num.f.1*0.6)),
                   rep('35+',num.f.1-round(num.f.1*0.25)-round(num.f.1*0.6)),
                   rep('15-24',round(num.m.1*0.2)),
                   rep('25-34',round(num.m.1*0.5)),
                   rep('35+',num.m.1-round(num.m.1*0.2)-round(num.m.1*0.5)),
                   rep('15-24',round(num.f.2*0.25)),
                   rep('25-34',round(num.f.2*0.5)),
                   rep('35+',num.f.2-round(num.f.2*0.25)-round(num.f.2*0.5)),
                   rep('15-24',round(num.m.2*0.2)),
                   rep('25-34',round(num.m.2*0.4)),
                   rep('35+',num.m.2-round(num.m.2*0.2)-round(num.m.2*0.4))
                   )

```
Based on these covariates, we compute the number of infected individuals $X_a^i$ in each subpopulation stratified by age, gender and locations. Assume regression coefficients as follows:

1. intercept: 0.4
2. varying intercepts for location 1 and 2: 0.5,-0.5
3. regression coefficients for the variables 'being male', 'being young' and 'being mid-age' are 0.4, 0.3 and 0.2. 
```{r} 
dg		<- dg[, list(TRIAL=length(INF)),by=c('AGE_AT_MID_C','SEX','COMM_NUM_B')]
comm<-c(0.5,-0.5)
a<-0.4
male<-0.4
young<-0.3
midage<-0.2
```

Age and genders are then binarised for regression covariates which are then used to evaluate the sampling rate of group a $\mbox{logit}(\xi_a)$. Based on $\xi_a$, the number of individuals being sequenced $X_a^s$ is generated by a Binomial distribution $\mbox{Binomial}(X_a^i,\xi_a)$.
```{r} 
dg[, AGE1:= as.integer(AGE_AT_MID_C=='15-24')]
dg[, AGE2:= as.integer(AGE_AT_MID_C=='25-34')]
dg[, MALE:= as.integer(SEX=='M')]

dg[,LOGIT_P_SEQ:=a + comm[COMM_NUM_B] + male*MALE + young*AGE1 + midage*AGE2]
dg[,P_SEQ:=exp(LOGIT_P_SEQ)/(1+exp(LOGIT_P_SEQ))]
dg[,SUC:=rbinom(nrow(dg),TRIAL,P_SEQ)]

dg[,CATEGORY:=paste0(COMM_NUM_B,':',SEX,':',AGE_AT_MID_C)]
dg[,COMM_NUM_B:=as.integer(COMM_NUM_B)]
```


'dc' is created by all ordered combination of subpopulations in 'dg' and only heterosexual transmission pairs are kept.
```{r} 
dc<-as.data.table(expand.grid(TR_CATEGORY=dg$CATEGORY,REC_CATEGORY=dg$CATEGORY))
dc[,COUNT_ID:=1:nrow(dc)]
dc[, c("TR_COMM_NUM_B","TR_SEX", "TR_AGE_AT_MID_C") := tstrsplit(TR_CATEGORY, ":", fixed=TRUE)]
dc[, c("REC_COMM_NUM_B","REC_SEX", "REC_AGE_AT_MID_C") := tstrsplit(REC_CATEGORY, ":", fixed=TRUE)]

dc<-dc[TR_SEX!=REC_SEX,]
```

Assume transmissions are less likely to occur between different locations, to elder individuals in male-female transmissions and to younger individuals in female-male transmissions. Dirichlet parameters are set to be around 1 for these less probable pairs and around 2 for the rest of pairs. The probabilities of transmissions between subpopulations are then generated from a Dirichlet distribution with parameter described above.

```{r} 
lbd<-matrix(NA_real_,nrow = 1, ncol = nrow(dc))
for (i in 1:nrow(dc)){
  if (dc$TR_COMM_NUM_B[i]==dc$REC_COMM_NUM_B[i]){
    if ( (dc$TR_AGE_AT_MID_C[i]=='15-24' & dc$REC_AGE_AT_MID_C[i]=='25-34') |
         (dc$TR_AGE_AT_MID_C[i]=='15-24' & dc$REC_AGE_AT_MID_C[i]=='35+') |
         (dc$TR_AGE_AT_MID_C[i]=='25-34' & dc$REC_AGE_AT_MID_C[i]=='35+')){
      if (dc$TR_SEX[i]=='M'){
        lbd[i]<-rnorm(1,1,0.2)
      }else{
        lbd[i]<-rnorm(1,2,0.2)
      }
    }else if ( (dc$REC_AGE_AT_MID_C[i]=='15-24' & dc$TR_AGE_AT_MID_C[i]=='25-34') |
               (dc$REC_AGE_AT_MID_C[i]=='15-24' & dc$TR_AGE_AT_MID_C[i]=='35+') |
               (dc$REC_AGE_AT_MID_C[i]=='25-34' & dc$TR_AGE_AT_MID_C[i]=='35+')){
      if (dc$TR_SEX[i]=='M'){
        lbd[i]<-rnorm(1,2,0.2)
      }else{
        lbd[i]<-rnorm(1,1,0.2)
      }
    }else if(dc$TR_AGE_AT_MID_C[i]==dc$REC_AGE_AT_MID_C[i]){
      lbd[i]<-rnorm(1,2,0.2)
    }
  }else{
    lbd[i]<-rnorm(1,1,0.2)
  }
}
TRUE_PI<-rdirichlet(1,lbd)
```


Predicted sequencing rates for each subpopulation in 'dg' are used to evaluate the probability of a transmission between two subpopulations being observed.
```{r} 
tmp<-subset(dg,select=c('CATEGORY','P_SEQ'))
setnames(tmp,colnames(tmp),paste0('TR_',colnames(tmp)))
dc<-merge(dc,tmp,by='TR_CATEGORY')
setnames(tmp,colnames(tmp),gsub('TR_','REC_',colnames(tmp)))
dc<-merge(dc,tmp,by='REC_CATEGORY')
dc[,S:=TR_P_SEQ*REC_P_SEQ]
```

Assume the observed transmission count is 20, and the observed transmissions between subpopulations can be simulated as follows:

1. generate the true transmission count $Z \sim \mbox{Poisson} (20/S)$
2. generate the true transmissions between groups $z \sim \mbox{Multinomial} (Z,\pi)$
3. generate the observed transmissions between groups $n_{ab} \sim \mbox{Binomial} (z_{ab},\vartheta_{ab}), \forall a,b$

```{r} 
N<-rpois(1,20/mean(dc$S))
z<-rmultinom(1,size=N,prob=TRUE_PI)
n<-matrix(NA_integer_,ncol=1,nrow=length(TRUE_PI))
for (i in 1:length(TRUE_PI)){
  n[i]<-rbinom(1,size=z[i],dc$S[i])
}
```

Observed transmissions between groups are recorded from the simulation and ids are set for stratified transmissions.

```{r} 
dc$OBS<-n
dc.obs.zero<-which(dc$OBS==0)
dc<-dc[which(dc$OBS!=0),]
dc$COUNT_ID<-1:nrow(dc)

# remove irrelevant terms
dg$P_SEQ<-NULL
dg$LOGIT_P_SEQ<-NULL
dc$TR_P_SEQ<-NULL
dc$REC_P_SEQ<-NULL
dc$S<-NULL
dc[,TR_COMM_NUM_B:=as.integer(TR_COMM_NUM_B)]
dc[,REC_COMM_NUM_B:=as.integer(REC_COMM_NUM_B)]
```

df.sampling is a list of data table composed of dg.
```{r} 
df.sampling<-list()
df.sampling[[1]]<-dg
```
Here we present the form of the inputs of prior generator under GLM, i.e. **df.sampling** and **dc**.
```{r,echo=FALSE} 
library(knitr)
kable(df.sampling[[1]],caption = 'df.sampling[[1]]')
kable(dc,caption = 'dc')
```

We now draw samples from the prior distribution using GLM using function 'samples.from.GLM.prior' from this package. 

```{r}
samples.from.GLM.prior(df.sampling=df.sampling,dc=dc,iteration=1e5,sample.method='empirical',glm.model=c('binomial'),seed=123)
```

Information required (i.e. unique.pairs.index, S.DTL.prior and TR_OBS) for implementing the algorithm is loaded. The algorithm aims to infer the proportion of transmissions between subpopulations when correcting for sampling differences.
```{r}
load('InputsMCMC_GLM1e+05.rda')
mcmc.core.inference(s.dtl.prior=S.DTL.prior,tr.obs=TR_OBS)
```


Then the results from the algorithm can be extracted and we summarised the proportions of transmissions between subpopulations in the table below.
```{r}
load('core_correct_inference_SNPIZ_mcmcEachCount.rda')
# runtime of the algorithm
print(time)

dc.obs.nonzero<-setdiff(1:length(TRUE_PI),dc.obs.zero)
PI.summary<-data.table(PI_MEDIAN=rep(0,length(TRUE_PI)),
                       PI_LOWER=rep(0,length(TRUE_PI)),
                       PI_UPPER=rep(0,length(TRUE_PI)),
                       PI_TRUE=TRUE_PI,
                       ID=1:length(TRUE_PI))
PI.summary$PI_MEDIAN[dc.obs.nonzero]<-apply(mc$pars$PI,2,median)
PI.summary$PI_LOWER[dc.obs.nonzero]<-apply(mc$pars$PI,2,function(x){quantile(x,0.025)})
PI.summary$PI_UPPER[dc.obs.nonzero]<-apply(mc$pars$PI,2,function(x){quantile(x,0.975)})
```


```{r,echo=FALSE}
kable(PI.summary,caption = 'summary of PI')
```

If you want to visualise MCMC convergence diagnostics, you may use the function 'mcmc.core.inference.diagnostics' and all the results are saved in your computer.
```{r}
mcmc.core.inference.diagnostics(mc,2e3)
```

