data(twoGroupFlows1_mcmc, package="phyloflows")
outfile.base <- file.path(getwd(),'twoGroupFlows1_mcmc_') #
control <- list( burnin.p=0.05, #
                 regex_pars='*', #
				 credibility.interval=0.95, #
				 pdf.plot.all.parameters=FALSE, #
				 pdf.plot.n.worst.case.parameters=10, #
				 pdf.height.per.par=1.2, #
				 outfile.base=outfile.base)
control
require(data.table)#
require(phyloflows)
phyloflow:::source.attribution.mcmc.diagnostics(mc, control=control)
phyloflows:::source.attribution.mcmc.diagnostics(mc, control=control)
phyloflows:::source.attribution.mcmc.diagnostics(mc=mc, control=control)
build_articles('~/git/phyloscanner/phyloflows')
build_article('~/git/phyloscanner/phyloflows')
require(pkgdown)
build_site('~/git/phyloscanner/phyloflows')
infile.hiv	<- '~/Dropbox (SPH Imperial College)/2016_ATHENA_Oct_Update/processed_democlin/ATHENA_1610_All_PatientKeyCovariates_Numeric.rda'
z<- load(infile.hiv)
z
require(data.table)
df.all
file			<- '~/Dropbox (SPH Imperial College)/2016_ATHENA_Oct_Update/original_161102/SHM_1602_161102_OR_ALL_Immu.csv'
df				<- read.csv(file, stringsAsFactors=FALSE)
file			<- '~/Dropbox (SPH Imperial College)/2016_ATHENA_Oct_Update/original_latest/SHM_1602_161102_OR_ALL_Immu.csv'
df				<- read.csv(file, stringsAsFactors=FALSE)
head(df)
file			<- '~/Dropbox (SPH Imperial College)/2016_ATHENA_Oct_Update/original_latest/SHM_1602_161102_OR_ALL_Regimens.xlsx'
require(gdata)
df		<- as.data.table(read.xls(file, stringsAsFactors=FALSE))
require(Phyloscanner.R.utilities)#
	require(phyloscannerR)#
	require(tidyverse)	#
	#	load phyloscanner data	#
	file	<- system.file(file.path('extdata','ptyr192_phsc_analyse_trees_output.R'),package='phyloscannerR')#
	load(file)	#loads 'phsc', output from 'phyloscanner.analyse.trees'#
	#	use distance thresholds found in analysis of Rakai couples#
	close.threshold	<- 0.025#
	distant.threshold	<- 0.05	#
	#	use relationship types based on adjacency#
	#	this also considers linkage etc between individuals who have dual infections, recombinants etc #
	#	..and thus may not have *all* their subgraphs adjacent to each other#
	relationship.types	<- c('proximity.3.way',#
			'any.ancestry',#
			'close.x.contiguous',			#
			'close.and.adjacent',					#
			'close.and.adjacent.and.directed',					#
			'close.and.adjacent.and.ancestry',			#
			'close.and.contiguous',					#
			'close.and.contiguous.and.directed',					#
			'close.and.contiguous.and.ancestry')	#
	use.paths.to.define.relationships <- TRUE#
	dwin	<- classify.pairwise.relationships(phsc, #
								allow.mt=TRUE, #
								close.threshold=close.threshold, #
								distant.threshold=distant.threshold,#
								use.paths.to.define.relationships=use.paths.to.define.relationships,#
								relationship.types=relationship.types, #
								verbose=TRUE)
# select windows by read and tip count#
	tip.regex <- "^(.*)_fq[0-9]+_read_([0-9]+)_count_([0-9]+)$"#
	min.reads <- 30#
	min.tips <- 1#
	dwin <- select.windows.by.read.and.tip.count(phsc, dwin, tip.regex, min.reads, min.tips)#
	# count phylogenetic relationships across deep-sequence trees#
	dc <- count.pairwise.relationships(dwin)#
	dwinn <- copy(dwin)#
	require(data.table)#
	file <- '~/sandbox/DeepSeqProjects/RakaiPopSample_phyloscanner_analysis/ptyr192_pairwise_relationships.rda'#
	load(file)#
	tmp	<- dwinn %>% #
			select(host.1,host.2,tree.id,basic.classification,categorical.distance)#
	#%>%#
	#		mutate(TYPE_BASIC:= paste0(basic.classification,'_',categorical.distance)) %>%#
	#		select(-basic.classification,-categorical.distance)#
	tmp2 <- subset(dwin, select=c(ID1,ID2,SUFFIX,TYPE_BASIC))#
	set(tmp2, NULL, 'ID1', tmp2[, as.character(ID1)])#
	set(tmp2, NULL, 'ID2', tmp2[, as.character(ID2)])#
	tmp2[, BASIC_CLASSIFICATION:= gsub('\n| ','_',gsub('chain 21','desc',gsub('chain 12','anc',gsub('with intermediate','noncontiguous',gsub('no intermediate','contiguous',gsub('\nclose|\ndistant| close| distant','',TYPE_BASIC))))))]#
	tmp2[, CATEGORICAL_DISTANCE:= 'intermediate']#
	set(tmp2, tmp2[, which(grepl('close',TYPE_BASIC))], 'CATEGORICAL_DISTANCE', 'close')#
	set(tmp2, tmp2[, which(grepl('distant',TYPE_BASIC))], 'CATEGORICAL_DISTANCE', 'distant')#
	setnames(tmp2, c('ID1','ID2','SUFFIX'), c('host.1','host.2','tree.id'))	#
	tmp	<- tmp %>% full_join(tmp2, by=c('host.1','host.2','tree.id'))#
	tmp %>% filter( basic.classification!=BASIC_CLASSIFICATION )
dwinn==dwin
require(Phyloscanner.R.utilities)#
	require(phyloscannerR)#
	require(tidyverse)	#
	#	load phyloscanner data	#
	file	<- system.file(file.path('extdata','ptyr192_phsc_analyse_trees_output.R'),package='phyloscannerR')#
	load(file)	#loads 'phsc', output from 'phyloscanner.analyse.trees'#
	#	use distance thresholds found in analysis of Rakai couples#
	close.threshold	<- 0.025#
	distant.threshold	<- 0.05	#
	#	use relationship types based on adjacency#
	#	this also considers linkage etc between individuals who have dual infections, recombinants etc #
	#	..and thus may not have *all* their subgraphs adjacent to each other#
	relationship.types	<- c('proximity.3.way',#
			'any.ancestry',#
			'close.x.contiguous',			#
			'close.and.adjacent',					#
			'close.and.adjacent.and.directed',					#
			'close.and.adjacent.and.ancestry',			#
			'close.and.contiguous',					#
			'close.and.contiguous.and.directed',					#
			'close.and.contiguous.and.ancestry')	#
	use.paths.to.define.relationships <- TRUE#
	dwin	<- classify.pairwise.relationships(phsc, #
								allow.mt=TRUE, #
								close.threshold=close.threshold, #
								distant.threshold=distant.threshold,#
								use.paths.to.define.relationships=use.paths.to.define.relationships,#
								relationship.types=relationship.types, #
								verbose=TRUE)		#
	# select windows by read and tip count#
	tip.regex <- "^(.*)_fq[0-9]+_read_([0-9]+)_count_([0-9]+)$"#
	min.reads <- 30#
	min.tips <- 1#
	dwin <- select.windows.by.read.and.tip.count(phsc, dwin, tip.regex, min.reads, min.tips)#
	# count phylogenetic relationships across deep-sequence trees#
	dc <- count.pairwise.relationships(dwin)
migcnts	<- list(dc=dc, dwin=dwin)#
	file <- '~/sandbox/DeepSeqProjects/RakaiPopSample_RakaiPopSample_migcode/ptyr192_pairwise_relationships_branch_migrateCounts.rda'#
	save(migcnts, file=file)
file <- '~/sandbox/DeepSeqProjects/RakaiPopSample_migcode/ptyr192_pairwise_relationships_branch_migrateCounts.rda'#
	save(migcnts, file=file)
10*500//60
10*500/60
10*500/60/24
z		<- as.data.table(read.csv("~/Dropbox (SPH Imperial College)/Rakai Fish Analysis/full_run/RakaiAll_output_190327_w250_s20_p25_d50_stagetwo_rerun23_min30_conf60_phylogeography_samcmc190327_nsweep1e5_opt112401020_prAreas_PIGender_flowsetc.csv"))
z
z		<- as.data.table(read.csv("~/Dropbox (SPH Imperial College)/Rakai Fish Analysis/full_run/RakaiAll_output_190327_w250_s20_p25_d50_stagetwo_rerun23_min30_conf60_phylogeography_samcmc190327_nsweep1e5_opt112401020_prAreas_PI_flowsetc.csv"))#
	z		<- subset(z, STAT=='flow_ratio')	#
	ggplot(z, aes(y=STAT)) + 			#
			geom_vline(xintercept=1, lty=2) +#
			geom_point(aes(x=M), size=2) +#
			geom_errorbarh(aes(xmin=CL, xmax=CU), height=0.4) +#
			scale_x_log10(expand=c(0,0), breaks=c(1/10,1/4,1/2,1,2,4,10), labels=c('1/10','1/4','1/2','1','2','4','10')) +#
			labs(x= '\nestimated flow ratio', y='') +#
			coord_cartesian(xlim=c(1/10,10)) +#
			theme_classic()
z
ggsave(file=gsub('\\.rda','_flowRatioOverall.pdf',mcmc.file), w=5, h=2, useDingbats=FALSE)
ggsave(file='~/Dropbox (SPH Imperial College)/Rakai Fish Analysis/full_run/RakaiAll_output_190327_w250_s20_p25_d50_stagetwo_rerun23_min30_conf60_phylogeography_samcmc190327_nsweep1e5_opt112401020_prAreas_flowRatioOverall.pdf', w=5, h=2, useDingbats=FALSE)
sessionInfo()
install.packages("BiocManager")
BiocManager::install("ggtree")
options("warn"=1)#
#
suppressMessages(require(argparse, quietly=TRUE, warn.conflicts=FALSE))#
suppressMessages(require(phyloscannerR, quietly=TRUE, warn.conflicts=FALSE))#
suppressMessages(require(network, quietly=TRUE, warn.conflicts=FALSE))#
suppressMessages(require(ggplot2, quietly=TRUE, warn.conflicts=FALSE))#
suppressMessages(require(sna, quietly=TRUE, warn.conflicts=FALSE))#
suppressMessages(require(scales, quietly=TRUE, warn.conflicts=FALSE))#
suppressMessages(require(readr, quietly=TRUE, warn.conflicts=FALSE))
args<- list(RDAonly = FALSE, alignment = NULL, alignmentFileExtension = ".fasta", #
    allClassifications = FALSE, allowMultiTrans = TRUE, blacklistReport = FALSE, #
    blacklistUnderrepresented = FALSE, collapsedTrees = FALSE, #
    csvFileExtension = ".csv", directionThreshold = 0.33, distanceThreshold = -1L, #
    dualBlacklist = FALSE, duplicateBlacklist = NULL, fileNameRegex = "^\\D*([0-9]+)_to_([0-9]+)\\D*$", #
    maxReadsPerHost = 50L, minReadsPerHost = 1L, minTipsPerHost = 1L, #
    multifurcationThreshold = "1e-05", multinomial = FALSE, noProgressBars = TRUE, #
    normRefFileName = "/Users/Oliver/git/phyloscanner/phyloscannerR/inst/HIV_DistanceNormalisationOverGenome.csv", #
    normStandardiseGagPol = TRUE, normalisationConstants = NULL, #
    outgroupName = "REF_CPX_AF460972", outputDir = NULL, outputNexusTree = FALSE, #
    outputRDA = TRUE, outputString = "ptyr101", overwrite = TRUE, #
    parsimonyBlacklistK = 20, pdfRelHeight = 0.15, pdfScaleBarWidth = 0.01, #
    pdfWidth = 50L, postHocCountBlacklisting = FALSE, pruneBlacklist = FALSE, #
    ratioBlacklistThreshold = "0", rawBlacklistThreshold = "20", #
    readCountsMatterOnZeroLengthBranches = TRUE, recombinationFiles = NULL, #
    relaxedAncestry = TRUE, seed = "42", skipSummaryGraph = FALSE, #
    splitsRule = "s,20", summaryPlotDimensions = 25L, tipRegex = "^(.*)_fq[0-9]+_read_([0-9]+)_count_([0-9]+)$", #
    tree = "/Users/Oliver/sandbox/DeepSeqProjects/RakaiPopSample_phsc_work/pty_19-05-20-12-24-54/ptyr101_trees_newick/ptyr101_InWindow_", #
    treeFileExtension = ".tree", useff = FALSE, userBlacklist = NULL, #
    verbose = 1L, windowThreshold = 0.5)
options(readr.num_columns = 0)#
#
# basics#
verbosity                       <- args$verbose#
#
if(!(verbosity %in% 0:2)){#
  stop("Invalid verbosity option: ",verbosity)#
}#
#
no.progress.bars                <- args$noProgressBars#
overwrite                       <- args$overwrite#
tree.fe                         <- args$treeFileExtension#
re.tree.fe                      <- gsub("\\.", "\\\\.", tree.fe)#
csv.fe                          <- args$csvFileExtension#
re.csv.fe                       <- gsub("\\.", "\\\\.", csv.fe)#
alignment.fe                    <- args$alignmentFileExtension#
re.alignment.fe                 <- gsub("\\.", "\\\\.", alignment.fe)#
#
# tree input#
tree.input                      <- args$tree#
#
if(!file.exists(tree.input)){#
  tree.directory                <- dirname(tree.input)#
#
  tree.file.regex               <- paste0("^", basename(tree.input), "(.*)", re.tree.fe, "$")#
  single.tree                   <- F#
#
} else {#
  if(file.info(tree.input)[['isdir']]){#
    tree.directory              <- tree.input#
    tree.file.regex             <- paste0("^(.*)", re.tree.fe, "$")#
    single.tree                 <- F#
  } else {#
    single.tree                 <- T#
  }#
}#
#
# user blacklist#
blacklist.input                 <- args$userBlacklist#
#
if(!is.null(blacklist.input)){#
  if(!file.exists(blacklist.input)){#
    user.blacklist.directory    <- dirname(blacklist.input)#
    user.blacklist.file.regex   <- paste0("^", basename(blacklist.input), "(.*)", re.csv.fe,"$")#
  }#
} else {#
  user.blacklist.directory      <- NULL#
  user.blacklist.file.regex     <- NULL#
}#
#
# alignment files#
alignment.input                 <- args$alignment#
#
if(!is.null(alignment.input)){#
  if(!file.exists(alignment.input)){#
    alignment.directory         <- dirname(alignment.input)#
    alignment.file.regex        <- paste0("^", basename(alignment.input), "(.*)", re.alignment.fe,"$")#
  }#
} else {#
  alignment.directory           <- NULL#
  alignment.file.regex          <- NULL#
}#
#
# output files#
output.dir                      <- args$outputDir#
if(is.null(output.dir)){#
  output.dir                    <- getwd()#
}#
#
if(!dir.exists(output.dir)){#
  stop("Specified output directory (",output.dir,") does not exist.")#
}#
#
output.string                   <- args$outputString#
if(!overwrite & length(list.files(path=output.dir, pattern=paste0("^", output.string, ".*")))>0 ){#
  stop("Previous output with this output string (",output.string,") detected. Please re-run with --overwrite if you wish to overwrite this.")#
}#
#
# outgroup name#
outgroup.name                   <- args$outgroupName#
#
if(is.null(outgroup.name)){#
  warning("No outgroup name provided. Trees are assumed to be correctly rooted.")#
}#
#
# multifurcation threshold#
use.m.thresh                    <- !is.null(args$multifurcationThreshold)#
#
if(use.m.thresh){#
  if(args$multifurcationThreshold=="g"){#
    m.thresh                    <- NA#
  } else if(!is.na(as.numeric(args$multifurcationThreshold))){#
    m.thresh                    <- as.numeric(args$multifurcationThreshold)#
  } else {#
    stop("Unknown argument for --multifurcationThreshold specified\n")#
  }#
} else {#
  m.thresh                      <- -1#
}#
#
# PDF tree dimensions#
pdf.hm                        <- as.numeric(args$pdfRelHeight)#
pdf.w                         <- as.numeric(args$pdfWidth)#
pdf.scale.bar.width           <- as.numeric(args$pdfScaleBarWidth)#
#
# Random number seed#
seed                          <- args$seed#
if(is.null(seed)){#
  seed                        <- sample.int(1000000000, 1)#
} else {#
  seed                        <- as.numeric(seed)#
}#
if(verbosity!=0) cat("Random number seed is",seed,"\n")#
set.seed(seed)#
#
# Output RDA?#
output.rda                    <- args$outputRDA | args$RDAonly#
output.files                  <- !args$RDAonly#
#
# Normalisation options#
norm.ref.file.name            <- args$normRefFileName#
norm.standardise.gp           <- args$normStandardiseGagPol#
norm.constants.input          <- args$normalisationConstants#
if(!is.null(norm.ref.file.name) & !is.null(norm.constants.input)){#
  warning("Normalisation reference file name and predetermined normalisation constants both specified. Only the latter will be used.")#
}#
#
# Regexes for suffixes and window coordinates#
tip.regex                     <- args$tipRegex#
file.name.regex               <- args$fileNameRegex#
#
# What blacklisting to do and how#
do.dup.blacklisting           <- !is.null(args$duplicateBlacklist)#
dup.input.file.name           <- args$duplicateBlacklist#
if(!is.null(dup.input.file.name)){#
  if(!file.exists(dup.input.file.name)){#
    duplicate.file.directory    <- dirname(dup.input.file.name)#
    duplicate.file.regex        <- paste0("^", basename(dup.input.file.name), "(.*)\\.[A-Za-z]+$")#
  }#
} else {#
  duplicate.file.directory    <- NULL#
  duplicate.file.regex        <- NULL#
}#
#
do.par.blacklisting           <- !is.null(args$parsimonyBlacklistK)#
par.blacklisting.k            <- args$parsimonyBlacklistK#
if(is.null(par.blacklisting.k)){#
  par.blacklisting.k          <- 0#
}#
do.dual.blacklisting          <- args$dualBlacklist#
#
output.blacklisting.report    <- args$blacklistReport#
if(output.blacklisting.report & !output.files){#
  warning("You asked for the blacklist report but also for no output files. No file will be produced.")#
}#
#
bl.raw.threshold              <- as.numeric(args$rawBlacklistThreshold)#
bl.ratio.threshold            <- as.numeric(args$ratioBlacklistThreshold)#
#
if(do.par.blacklisting & bl.raw.threshold == 0 & bl.ratio.threshold == 0){#
  stop("Parsimony blacklisting requested but no thresholds specified with -rwt or -rtt")#
}#
if(do.dup.blacklisting & bl.raw.threshold == 0 & bl.ratio.threshold == 0){#
  stop("Duplicate blacklisting requested but no thresholds specified with -rwt or -rtt")#
}#
#
# Slow runs using less memory#
useff                         <- args$useff#
# if(useff){#
#   suppressMessages(require(ff, quietly=TRUE, warn.conflicts=FALSE))#
# }#
#
# read and tip count blacklisting#
min.reads.per.host            <- args$minReadsPerHost#
min.tips.per.host             <- args$minTipsPerHost#
#
post.hoc.min.counts           <- args$postHocCountBlacklisting#
# Downsampling#
downsampling.limit            <- args$maxReadsPerHost#
if(is.null(downsampling.limit)){#
  downsampling.limit          <- Inf#
}#
blacklist.ur                  <- args$blacklistUnderrepresented#
#
# Miscellaneous options#
read.counts.matter            <- args$readCountsMatterOnZeroLengthBranches#
prune.blacklist               <- args$pruneBlacklist#
#
# What reconstruction mode to use#
reconst.mode.arg              <- args$splitsRule#
reconst.mode.arg              <- unlist(strsplit(reconst.mode.arg, ","))#
#
if(!(reconst.mode.arg[1] %in% c("r", "s"))){#
  stop(paste("Unknown split classifier: ", reconst.mode.arg[1], "\n", sep=""))#
}#
#
reconstruction.mode           <- reconst.mode.arg[1]#
#
if(reconstruction.mode == "r" & length(reconst.mode.arg)>1){#
  warning("Romero-Severson reconstuction takes no additional arguments; ignoring everything after 'r'")#
}#
#
if(reconstruction.mode=="s" & length(reconst.mode.arg)==1){#
  stop("One additional argument is required for Sankoff reconstruction")#
}#
#
if(reconstruction.mode=="s"){#
  sankoff.k                  <- as.numeric(reconst.mode.arg[2])#
  sankoff.p                  <- 0#
  if(is.na(sankoff.k)){#
    stop("Expected numerical arguments for reconstruction algorithm parameters.")#
  }#
} else {#
  sankoff.k                  <- NA#
  sankoff.p                  <- NA#
}#
#
# Whether to output trees#
if(args$outputNexusTree){#
  tree.output.format         <- "nex"#
  if(!output.files){#
    warning("You asked for Nexus trees but also for no output files. No trees will be produced.")#
  }#
} else {#
  tree.output.format         <- "pdf"#
}#
#
recomb.input                   <- args$recombinationFiles#
do.recomb                      <- !is.null(recomb.input)#
if(do.recomb){#
  if(!file.exists(recomb.input)){#
    recomb.file.directory      <- dirname(recomb.input )#
    recomb.file.regex          <- paste0("^", basename(recomb.input), "(.*)\\.[A-Za-z]+$")#
  }#
} else {#
  recomb.file.directory      <- NULL#
  recomb.file.regex          <- NULL#
}#
#
# Output classification and collapsed tree files?#
do.collapsed                   <- args$collapsedTrees#
if(do.collapsed & !output.files){#
  warning("You asked for collapsed tree files but also for no output files. No files will be produced.")#
}#
do.class.detail                <- args$allClassifications#
if(do.class.detail & !output.files){#
  warning("You asked for classification files but also for no output files. No files will be produced.")#
}#
#
multinomial                    <- args$multinomial#
#
# Thresholds for summaries#
win.threshold                  <- args$windowThreshold#
dist.thresholds                <- args$distanceThreshold#
if(length(dist.thresholds == 1)){#
  if(!multinomial){#
    if(dist.thresholds[[1]] == -1){#
      dist.threshold <- Inf#
    } else {#
      dist.threshold <- dist.thresholds[[1]]#
    }#
  } else {#
    if(dist.thresholds[[1]] == -1){#
      stop("A finite distance threshold must be specified for the multinomial model")#
    } else {#
      close.threshold <- dist.thresholds[[1]]#
      distant.threshold <- dist.thresholds[[1]]#
    }#
  } #
} else {#
  if(!multinomial){#
    warning("More arguments than expected to --distanceThreshold. Ignoring all but the first.")#
    if(dist.thresholds[[1]] == -1){#
      dist.threshold <- Inf#
    } else {#
      dist.threshold <- dist.thresholds[[1]]#
    }#
  } else {#
    if(length(dist.thresholds > 2)){#
      warning("More arguments than expected to --distanceThreshold. Ignoring all but the first two")#
    } #
    close.threshold <- dist.thresholds[[1]]#
    distant.threshold <- dist.thresholds[[2]]#
    if(close.threshold == -1 | distant.threshold == -1){#
      stop("Finite distance thresholds must be specified for the multinomial model")#
    }#
    if(close.threshold > distant.threshold){#
      stop("Threshold for close pairs must be smaller than or equal to threshold for distant pairs.")#
    }#
  }#
}#
#
arrow.threshold                <- args$directionThreshold#
#
if(arrow.threshold >= win.threshold){#
  stop("Direction threshold cannot be larger than window threshold")#
}#
#
allow.mt                       <- args$allowMultiTrans#
relaxed.ancestry               <- args$relaxedAncestry#
#
# Do the simplified plot?#
do.simplified.graph            <- !args$skipSummaryGraph#
simp.plot.dim                  <- args$summaryPlotDimensions
single.tree
phyloscanner.trees <- phyloscanner.analyse.trees(#
    tree.directory,#
    tree.file.regex,#
    reconstruction.mode,#
    sankoff.k,#
    sankoff.unassigned.switch.threshold = 0,#
    continuation.unassigned.proximity.cost = 1000,#
    outgroup.name,#
    m.thresh,#
    is.na(m.thresh),#
    user.blacklist.directory,#
    user.blacklist.file.regex,#
    duplicate.file.directory,#
    duplicate.file.regex,#
    recomb.file.directory,#
    recomb.file.regex,#
    alignment.directory,#
    alignment.file.regex,#
    tip.regex,#
    file.name.regex,#
    seed,#
    norm.ref.file.name,#
    norm.standardise.gp,#
    norm.constants.input,#
    allow.mt,#
    relaxed.ancestry,#
    par.blacklisting.k,#
    bl.raw.threshold,#
    bl.ratio.threshold,#
    do.dual.blacklisting,#
    downsampling.limit,#
    blacklist.ur,#
    ifelse(post.hoc.min.counts, 1, min.reads.per.host),#
    ifelse(post.hoc.min.counts, 1, min.tips.per.host),#
    useff,#
    prune.blacklist,#
    read.counts.matter,#
    verbosity,#
    no.progress.bars)
hosts <- all.hosts.from.trees(phyloscanner.trees)#
#
if(length(hosts) <= 1 & (do.collapsed | do.class.detail)){#
  do.collapsed <- F#
  do.class.detail <- F#
}
if(verbosity!=0 & output.files){#
  cat("Writing annotated trees in .",tree.output.format," format...\n", sep="")#
}
ptree<- phyloscanner.trees[[1]]
ptree
file.name <- paste0(output.string, "_processedTree_", ptree$id, ".", tree.output.format)
file.name
write.annotated.tree(ptree, file=file.path(output.dir, file.name), tree.output.format, pdf.scale.bar.width, pdf.w, pdf.hm, verbosity == 2)
if(output.files){#
  silent <- sapply(phyloscanner.trees, function(ptree){#
    if(single.tree){#
      file.name <- paste0(output.string, "_processedTree.", tree.output.format)#
    } else {#
      file.name <- paste0(output.string, "_processedTree_", ptree$id, ".", tree.output.format)#
    }#
    write.annotated.tree(ptree, file=file.path(output.dir, file.name), tree.output.format, pdf.scale.bar.width, pdf.w, pdf.hm, verbosity == 2)#
  }, simplify = F, USE.NAMES = T)#
}
output.dir
if(do.collapsed & output.files){#
  if(verbosity!=0){#
    cat("Writing collapsed trees to ",csv.fe," files...\n", sep="")#
  }#
  silent <- sapply(phyloscanner.trees, function(ptree){#
    if(single.tree){#
      file.name <- paste0(output.string, "_collapsedTree", csv.fe)#
    } else {#
      file.name <- paste0(output.string, "_collapsedTree_", ptree$id, csv.fe)#
    }#
    if(verbosity==2) cat("Writing collapsed tree for tree ID ",ptree$id," to file ",file.name, "...\n", sep="")#
    write_csv(ptree$classification.results$collapsed[,1:4], file.path(output.dir, file.name))#
  }, simplify = F, USE.NAMES = T)#
}
if(do.class.detail & output.files){#
  if(verbosity!=0){#
    cat("Writing host pairwise classifications to ",csv.fe," files...\n", sep="")#
  }#
  silent <- sapply(phyloscanner.trees, function(ptree){#
    if(single.tree){#
      file.name <- paste0(output.string, "_classification", csv.fe)#
    } else {#
      file.name <- paste0(output.string, "_classification_", ptree$id, csv.fe)#
    }#
    if(verbosity==2) cat("Writing relationship classifications for tree ID ",ptree$id," to file ",file.name, "...\n", sep="")#
    write_csv(ptree$classification.results$classification, file.path(output.dir, file.name))#
  }, simplify = F, USE.NAMES = T)#
}#
#
if(length(phyloscanner.trees)>1){#
  if(verbosity!=0){#
    cat("Calculating per-host summary statistics...\n", sep="")#
  }#
  summary.stats <- gather.summary.statistics(phyloscanner.trees, tip.regex = tip.regex, verbose = verbosity==2)#
  ss.csv.fn <- paste0(output.string,"_patStats", csv.fe)#
  if(verbosity!=0 & output.files){#
    cat("Writing summary statistics to file ",ss.csv.fn,"...\n", sep="")#
  }#
  if(output.files){#
  write_csv(summary.stats, file.path(output.dir, ss.csv.fn))#
  }#
  ss.graphs.fn <- paste0(output.string,"_patStats.pdf")#
  if(verbosity!=0 & output.files){#
    cat("Graphing summary statistics to file ",ss.graphs.fn,"...\n", sep="")#
  }#
  if(output.files){#
    silent <- multipage.summary.statistics(phyloscanner.trees, summary.stats, file.name = file.path(output.dir, ss.graphs.fn), verbose = verbosity==2)#
  }#
  hosts <- all.hosts.from.trees(phyloscanner.trees)#
  if(length(hosts)>1){#
    ts <- transmission.summary(phyloscanner.trees, win.threshold, dist.threshold, allow.mt, close.sib.only = F, verbosity==2)#
    if (verbosity!=0 & output.files) cat('Writing transmission summary to file ', paste0(output.string,"_hostRelationshipSummary", csv.fe),'...\n', sep="")#
    if(output.files){#
      write_csv(ts, file.path(output.dir, paste0(output.string,"_hostRelationshipSummary", csv.fe)))#
    }#
    if(do.simplified.graph){#
      if (verbosity!=0 & output.files) cat('Drawing simplified summary diagram to file ', paste0(output.string,"_simplifiedRelationshipGraph.pdf"),'...\n', sep="")#
      if(nrow(ts)==0){#
        cat("No relationships exist in the required proportion of windows (",win.threshold,"); skipping simplified relationship summary.\n", sep="")#
      } else {#
        simplified.graph <- simplify.summary(ts, arrow.threshold, length(phyloscanner.trees), plot = T)#
        if(output.files){#
          simplified.graph$simp.diagram#
          ggsave(file = file.path(output.dir, paste0(output.string,"_simplifiedRelationshipGraph.pdf")), width=simp.plot.dim, height=simp.plot.dim)#
        }#
      }#
    }#
  }#
}
if(output.blacklisting.report & output.files){#
  if (verbosity!=0) cat('Saving blacklisting report to file', paste0(output.string,"_blacklistReport",csv.fe),'...\n', sep="")#
  dfs <- lapply(phyloscanner.trees, function(x) {#
    treebl.df <- x$bl.report#
    if(nrow(treebl.df)>0){#
      treebl.df$tree.id <- x$id#
    } else {#
      treebl.df$tree.id <- vector()#
    }#
    treebl.df <- treebl.df[,c(4,1,2,3)]#
    treebl.df#
  })#
  output.bl.report <- do.call(rbind, dfs)#
  write_csv(output.bl.report, path = file.path(output.dir, paste0(output.string,"_blacklistReport",csv.fe)))#
}#
#
if(output.rda){#
  if (verbosity!=0) cat('Saving R workspace image to file ', paste0(output.string,"_workspace.rda"),'...\n', sep="")#
  save.image(file=file.path(output.dir, paste0(output.string,"_workspace.rda")))#
}
if(file.exists(file.path(output.dir, "Rplots.pdf"))) silent <- file.remove(file.path(output.dir, "Rplots.pdf"))
require(data.table)#
	require(phyloscannerR)#
	#	locate tree and patient files for each run#
	indir	<- '/Users/Oliver/sandbox/DeepSeqProjects/RakaiPopSample_deepseqtrees'#
	df	<- data.table(F=list.files(indir))	#
	df[, TYPE:= gsub('ptyr([0-9]+)_(.*)','\\2', F)]#
	set(df, NULL, 'TYPE', df[, gsub('^([^\\.]+)\\.[a-z]+$','\\1',TYPE)])#
	df[, RUN:= as.integer(gsub('ptyr([0-9]+)_(.*)','\\1', F))]#
	df	<- dcast.data.table(df, RUN~TYPE, value.var='F')#
	setnames(df, colnames(df), toupper(colnames(df)))#
	tmpdir	<- '/Users/Oliver/sandbox/DeepSeqProjects/RakaiPopSample_phsc_work'#
	outdir	<- '/Users/Oliver/sandbox/DeepSeqProjects/RakaiPopSample_phsc_out190512'#
	#	set phyloscanner variables#
	#	arguments as used for RCCS analysis#
	control	<- list()#
	control$allow.mt <- TRUE				#
	control$alignment.file.directory = NULL #
	control$alignment.file.regex = NULL#
	control$blacklist.underrepresented = FALSE	#
	control$count.reads.in.parsimony = TRUE#
	control$do.dual.blacklisting = FALSE					#
	control$duplicate.file.directory = NULL#
	control$duplicate.file.regex = NULL#
	control$file.name.regex = "^\\D*([0-9]+)_to_([0-9]+)\\D*$"#
	control$guess.multifurcation.threshold = FALSE#
	control$max.reads.per.host = 50#
	control$multifurcation.threshold = 1e-5#
	control$norm.constants = NULL#
	control$norm.ref.file.name = system.file('HIV_DistanceNormalisationOverGenome.csv',package='phyloscannerR')#
	control$norm.standardise.gag.pol = TRUE#
	control$no.progress.bars = TRUE#
	control$outgroup.name = "REF_CPX_AF460972"#
	control$output.dir = outdir#
	control$parsimony.blacklist.k = 20#
	control$prune.blacklist = FALSE#
	control$ratio.blacklist.threshold = 0 #
	control$raw.blacklist.threshold = 20					#
	control$recombination.file.directory = NULL#
	control$recombination.file.regex = NULL#
	control$relaxed.ancestry = TRUE#
	control$sankoff.k = 20#
	control$sankoff.unassigned.switch.threshold = 0#
	control$seed = 42#
	control$splits.rule = 's'#
	control$tip.regex = "^(.*)_fq[0-9]+_read_([0-9]+)_count_([0-9]+)$"#
	control$tree.file.regex = "^ptyr[0-9]+_InWindow_([0-9]+_to_[0-9]+)\\.tree$"#
	control$use.ff = FALSE#
	control$user.blacklist.directory = NULL #
	control$user.blacklist.file.regex = NULL#
	control$verbosity = 1
prog.phyloscanner_analyse_trees <- '/Users/Oliver/git/phyloscanner/phyloscanner_analyse_trees.R'#
	valid.input.args 				<- cmd.phyloscanner_analyse_trees.valid.args(prog.phyloscanner_analyse_trees)#
	cmds							<- vector('list',nrow(df))#
	for(i in seq_len(nrow(df)))#
	{#
		#	set input args#
		control$output.string 	<- paste0('ptyr',df[i,RUN])	#
		#	make script#
		tree.input				<- file.path(indir, df[i, TREES_NEWICK])#
		cmd						<- cmd.phyloscanner_analyse_trees(prog.phyloscanner_analyse_trees, #
				tree.input, #
				control,#
				valid.input.args=valid.input.args)#
		cmds[[i]]				<- cmd		#
	}	#
	cat(cmds[[100]])
control	<- list()#
	control$allow.mt <- TRUE				#
	control$alignment.file.directory = NULL #
	control$alignment.file.regex = NULL#
	control$blacklist.underrepresented = FALSE	#
	control$count.reads.in.parsimony = TRUE#
	control$do.dual.blacklisting = FALSE					#
	control$duplicate.file.directory = NULL#
	control$duplicate.file.regex = NULL#
	control$file.name.regex = "^\\D*([0-9]+)_to_([0-9]+)\\D*$"#
	control$guess.multifurcation.threshold = FALSE#
	control$max.reads.per.host = 50#
	control$multifurcation.threshold = 1e-5#
	control$norm.constants = NULL#
	control$norm.ref.file.name = system.file('HIV_DistanceNormalisationOverGenome.csv',package='phyloscannerR')#
	control$norm.standardise.gag.pol = TRUE#
	control$no.progress.bars = TRUE#
	control$outgroup.name = "REF_CPX_AF460972"#
	control$output.dir = outdir#
	control$parsimony.blacklist.k = 20#
	control$prune.blacklist = FALSE#
	control$ratio.blacklist.threshold = 0 #
	control$raw.blacklist.threshold = 20					#
	control$recombination.file.directory = NULL#
	control$recombination.file.regex = NULL#
	control$relaxed.ancestry = TRUE#
	control$sankoff.k = 20#
	control$sankoff.unassigned.switch.threshold = 0#
	control$seed = 42#
	control$splits.rule = 's'#
	control$tip.regex = "^(.*)_fq[0-9]+_read_([0-9]+)_count_([0-9]+)$"#
	control$tree.file.regex = "^ptyr[0-9]+_InWindow_([0-9]+_to_[0-9]+)\\.tree$"#
	control$use.ff = FALSE#
	control$user.blacklist.directory = NULL #
	control$user.blacklist.file.regex = NULL#
	control$verbosity = 1#
	#	make bash for one file#
	prog.phyloscanner_analyse_trees <- '/Users/Oliver/git/phyloscanner/phyloscanner_analyse_trees.R'#
	valid.input.args <- cmd.phyloscanner_analyse_trees.valid.args(prog.phyloscanner_analyse_trees)#
	tree.input <- system.file(file.path('extdata','Rakai_run192_trees.zip'),package='phyloscannerR')#
	control$output.string <- 'Rakai_run192'#
	cmd <- cmd.phyloscanner_analyse_trees(prog.phyloscanner_analyse_trees, #
			tree.input, #
			control,#
			valid.input.args=valid.input.args)#
	cat(cmd)
control
cmd.phyloscanner_analyse_trees<- function(prog.phyloscanner_analyse_trees, #
												tree.input, #
												control,#
												valid.input.args=cmd.phyloscanner_analyse_trees.valid.args(prog.phyloscanner_analyse_trees))#
{	#
	##
	#	prepare input args#
	##
	input.args		<- control#
	#	check that positional arguments are in control#
	stopifnot(any(names(input.args)=='splits.rule'))#
	stopifnot(any(names(input.args)=='output.string'))#
	#	prepare optional arguments with non-default values#
	tmp	<- which(names(input.args)=='guess.multifurcation.threshold')#
	if(length(tmp)>0)#
	{#
		if(input.args[['guess.multifurcation.threshold']])#
			input.args[['multifurcation.threshold']] <- 'g'#
		input.args <- input.args[names(input.args)!='guess.multifurcation.threshold']#
	}#
	tmp	<- which(names(input.args)=='sankoff.k')#
	if(length(tmp)>0)#
	{#
		if(input.args[['splits.rule']]=='s')#
			input.args[['splits.rule']] <- paste0(input.args[['splits.rule']],',',input.args[['sankoff.k']])#
		input.args <- input.args[names(input.args)!='sankoff.k']#
	}#
	#	extract positional arguments#
	splits.rule			<- input.args[['splits.rule']]#
	input.args			<- input.args[names(input.args)!='splits.rule']#
	output.string 		<- input.args[['output.string']]#
	input.args			<- input.args[names(input.args)!='output.string']#
	#	extract out.dir#
	out.dir				<- input.args[['output.dir']]#
	input.args			<- input.args[names(input.args)!='output.dir']#
	#	prepare optional argument names that are slightly inconsistent#
	names(input.args)	<- gsub('use.ff','useff',names(input.args))#
	names(input.args)	<- gsub('do.dual.blacklisting','dual.blacklist',names(input.args))#
	names(input.args)	<- gsub('allow.mt','allow.multi.trans',names(input.args))#
	names(input.args)	<- gsub('count.reads.in.parsimony','read.counts.matter.on.zero.length.branches',names(input.args))#
	names(input.args)	<- gsub('verbosity','verbose',names(input.args))#
	#	ignore arguments that are hard coded in the Rscript#
	input.args			<- input.args[names(input.args)!='tree.file.regex']#
	input.args 			<- input.args[names(input.args)!='sankoff.unassigned.switch.threshold']#
	#	replace .a with A where needed#
	tmp <- strsplit(names(input.args),'\\.')#
	tmp <- sapply(tmp, function(x) gsub('^([A-Z])','\\L\\1',paste(gsub('^([a-z])','\\U\\1',x,perl=TRUE),collapse=''),perl=TRUE))#
	tmp2 <- which(! names(input.args) %in% valid.input.args )	#
	names(input.args)[tmp2] <- tmp[tmp2]#
	#	add default optional arguments#
	input.args[['overwrite']]	<- TRUE#
	input.args[['outputRDA']]	<- TRUE#
	#	remove logical arguments that evaluate to FALSE#
	tmp 		<- !unname(sapply(input.args, function(x) is.logical(x) && x==FALSE))#
	input.args	<- input.args[tmp]			#
	#	check that all arguments are valid#
	tmp2 <- which(! names(input.args) %in% valid.input.args )#
	if(length(tmp2)>0)#
	{#
		stop('Found invalid arguments,',input.args[tmp2])#
	}	#
	#	for all character arguments: add encapsulating "" #
	#	for all logical arguments that evaluate to TRUE: keep only the name#
	for(ii in seq_along(input.args))#
	{#
		if(is.character(input.args[[ii]]) && !substr(input.args[[ii]],1,1)%in%c("'",'"'))#
			input.args[[ii]] <- paste0('"',input.args[[ii]],'"')#
		if(is.logical(input.args[[ii]]) && input.args[[ii]])#
			input.args[[ii]] <- ''#
	}	#
	#	sort arguments by name#
	tmp			<- sort(names(input.args), index.return=TRUE)$ix#
	input.args	<- input.args[tmp]#
	##
	#	make command#
	##
	#	create local tmp dir#
	cmd		<- paste("CWD=$(pwd)\n",sep='\n')#
	cmd		<- paste(cmd,"echo $CWD\n",sep='')#
	tmpdir	<- paste('pty','_',format(Sys.time(),"%y-%m-%d-%H-%M-%S"),sep='')	#
	tmpdir	<- paste("$CWD/",tmpdir,sep='')#
	cmd		<- paste(cmd,'mkdir -p "',tmpdir,'"\n',sep='')#
	#	if tree.input is zip file, extract and change tree.input to directory#
	if(grepl('\\.zip$',tree.input))#
	{		#
		tree.dir	<- gsub('\\.zip$','',file.path(tmpdir,basename(tree.input)))#
		cmd			<- paste(cmd,'mkdir -p "',tree.dir,'"\n',sep='')#
		cmd			<- paste(cmd,'unzip -j "',tree.input,'" -d "',tree.dir,'"\n',sep='')#
		#	passing directory is currently not supported, must pass base of tree file names before the window coordinates start#
		#	determine prefix of tree files via control$tree.file.regex#
		#	the regex must contain ()#
		if( !grepl('\\(',control$tree.file.regex) )#
			stop('Cannot make tree.input variable, expect control$tree.file.regex with () that identify window coordinates, found:',control$tree.file.regex)	#
		tmp				<- unzip(tree.input, list=TRUE)		#
		tmp$windowid	<- gsub(control$tree.file.regex, '\\1', tmp$Name)#
		tmp$prefix		<- sapply(seq_along(tmp$Name), function(x) gsub(paste0(tmp$windowid[x],'.*'),'',tmp$Name[x]))		#
		if( !all( tmp$prefix==tmp$prefix[1] ) )#
			stop('Cannot make tree.input variable, contact maintainer', tmp$Name)		#
		tree.input	<- file.path(tree.dir,tmp$prefix[1])#
	}	#
	#	add encapsulating "" to tree.input#
	if(!substr(tree.input,1,1)%in%c("'",'"'))#
		tree.input	<- paste0('"',tree.input,'"')#
	#	cd to tmp dir#
	cmd		<- paste(cmd, 'cd "',tmpdir,'"\n', sep='')	#
	#	add call with positional arguments#
	cmd		<- paste(cmd, prog.phyloscanner_analyse_trees,' ',tree.input,' ',output.string,' ',splits.rule, sep='')#
	#	add optional arguments#
	for(ii in seq_along(input.args))#
	{#
		cmd			<- paste0(cmd,' --',names(input.args)[[ii]])#
		if(input.args[[ii]]!='')#
			cmd		<- paste0(cmd,' ',input.args[[ii]])#
	}#
	#	copy to outdir#
	cmd		<- paste(cmd, '\nmv ',output.string,'_workspace.rda "',out.dir,'"\n',sep='')	#
	#	zip up everything else#
	cmd		<- paste(cmd, 'for file in *; do\n\tzip -ur9XTjq ',paste(output.string,'_otherstuff.zip',sep=''),' "$file"\ndone\n',sep='')#
	cmd		<- paste(cmd, 'mv ',paste(output.string,'_otherstuff.zip',sep=''),' "',out.dir,'"\n',sep='')#
	#	clean up#
	cmd		<- paste(cmd,'cd $CWD\nrm -rf "',tmpdir,'"\n',sep='')#
	cmd#
}
control	<- list()#
	control$allow.mt <- TRUE				#
	control$alignment.file.directory = NULL #
	control$alignment.file.regex = NULL#
	control$blacklist.underrepresented = FALSE	#
	control$count.reads.in.parsimony = TRUE#
	control$do.dual.blacklisting = FALSE					#
	control$duplicate.file.directory = NULL#
	control$duplicate.file.regex = NULL#
	control$file.name.regex = "^\\D*([0-9]+)_to_([0-9]+)\\D*$"#
	control$guess.multifurcation.threshold = FALSE#
	control$max.reads.per.host = 50#
	control$multifurcation.threshold = 1e-5#
	control$norm.constants = NULL#
	control$norm.ref.file.name = system.file('HIV_DistanceNormalisationOverGenome.csv',package='phyloscannerR')#
	control$norm.standardise.gag.pol = TRUE#
	control$no.progress.bars = TRUE#
	control$outgroup.name = "REF_CPX_AF460972"#
	control$output.dir = outdir#
	control$parsimony.blacklist.k = 20#
	control$prune.blacklist = FALSE#
	control$ratio.blacklist.threshold = 0 #
	control$raw.blacklist.threshold = 20					#
	control$recombination.file.directory = NULL#
	control$recombination.file.regex = NULL#
	control$relaxed.ancestry = TRUE#
	control$sankoff.k = 20#
	control$sankoff.unassigned.switch.threshold = 0#
	control$seed = 42#
	control$splits.rule = 's'#
	control$tip.regex = "^(.*)_fq[0-9]+_read_([0-9]+)_count_([0-9]+)$"#
	control$tree.file.regex = "^ptyr[0-9]+_InWindow_([0-9]+_to_[0-9]+)\\.tree$"#
	control$use.ff = FALSE#
	control$user.blacklist.directory = NULL #
	control$user.blacklist.file.regex = NULL#
	control$verbosity = 1#
	#	make bash for one file#
	prog.phyloscanner_analyse_trees <- '/Users/Oliver/git/phyloscanner/phyloscanner_analyse_trees.R'#
	valid.input.args <- cmd.phyloscanner_analyse_trees.valid.args(prog.phyloscanner_analyse_trees)#
	tree.input <- system.file(file.path('extdata','Rakai_run192_trees.zip'),package='phyloscannerR')#
	control$output.string <- 'Rakai_run192'#
	cmd <- cmd.phyloscanner_analyse_trees(prog.phyloscanner_analyse_trees, #
			tree.input, #
			control,#
			valid.input.args=valid.input.args)#
	cat(cmd)
prog.phyloscanner_analyse_trees <- '/Users/Oliver/git/phyloscanner/phyloscanner_analyse_trees.R'#
	valid.input.args 				<- cmd.phyloscanner_analyse_trees.valid.args(prog.phyloscanner_analyse_trees)#
	cmds							<- vector('list',nrow(df))#
	for(i in seq_len(nrow(df)))#
	{#
		#	set input args#
		control$output.string 	<- paste0('ptyr',df[i,RUN])	#
		#	make script#
		tree.input				<- file.path(indir, df[i, TREES_NEWICK])#
		cmd						<- cmd.phyloscanner_analyse_trees(prog.phyloscanner_analyse_trees, #
				tree.input, #
				control,#
				valid.input.args=valid.input.args)#
		cmds[[i]]				<- cmd		#
	}	#
	cat(cmds[[100]])
cmd.phyloscanner_analyse_trees<- function(prog.phyloscanner_analyse_trees, #
												tree.input, #
												control,#
												valid.input.args=cmd.phyloscanner_analyse_trees.valid.args(prog.phyloscanner_analyse_trees))#
{	#
	##
	#	prepare input args#
	##
	input.args		<- control#
	#	check that positional arguments are in control#
	stopifnot(any(names(input.args)=='splits.rule'))#
	stopifnot(any(names(input.args)=='output.string'))#
	#	prepare optional arguments with non-default values#
	tmp	<- which(names(input.args)=='guess.multifurcation.threshold')#
	if(length(tmp)>0)#
	{#
		if(input.args[['guess.multifurcation.threshold']])#
			input.args[['multifurcation.threshold']] <- 'g'#
		input.args <- input.args[names(input.args)!='guess.multifurcation.threshold']#
	}#
	tmp	<- which(names(input.args)=='sankoff.k')#
	if(length(tmp)>0)#
	{#
		if(input.args[['splits.rule']]=='s')#
			input.args[['splits.rule']] <- paste0(input.args[['splits.rule']],',',input.args[['sankoff.k']])#
		input.args <- input.args[names(input.args)!='sankoff.k']#
	}#
	#	extract positional arguments#
	splits.rule			<- input.args[['splits.rule']]#
	input.args			<- input.args[names(input.args)!='splits.rule']#
	output.string 		<- input.args[['output.string']]#
	input.args			<- input.args[names(input.args)!='output.string']#
	#	extract out.dir#
	out.dir				<- input.args[['output.dir']]#
	input.args			<- input.args[names(input.args)!='output.dir']#
	#	prepare optional argument names that are slightly inconsistent#
	names(input.args)	<- gsub('use.ff','useff',names(input.args))#
	names(input.args)	<- gsub('do.dual.blacklisting','dual.blacklist',names(input.args))#
	names(input.args)	<- gsub('allow.mt','allow.multi.trans',names(input.args))#
	names(input.args)	<- gsub('count.reads.in.parsimony','read.counts.matter.on.zero.length.branches',names(input.args))#
	names(input.args)	<- gsub('verbosity','verbose',names(input.args))#
	#	ignore arguments that are hard coded in the Rscript#
	input.args			<- input.args[names(input.args)!='tree.file.regex']#
	input.args 			<- input.args[names(input.args)!='sankoff.unassigned.switch.threshold']#
	#	replace .a with A where needed#
	tmp <- strsplit(names(input.args),'\\.')#
	tmp <- sapply(tmp, function(x) gsub('^([A-Z])','\\L\\1',paste(gsub('^([a-z])','\\U\\1',x,perl=TRUE),collapse=''),perl=TRUE))#
	tmp2 <- which(! names(input.args) %in% valid.input.args )	#
	names(input.args)[tmp2] <- tmp[tmp2]#
	#	add default optional arguments#
	input.args[['overwrite']]	<- TRUE#
	input.args[['outputRDA']]	<- TRUE#
	#	remove logical arguments that evaluate to FALSE#
	tmp 		<- !unname(sapply(input.args, function(x) is.logical(x) && x==FALSE))#
	input.args	<- input.args[tmp]			#
	#	check that all arguments are valid#
	tmp2 <- which(! names(input.args) %in% valid.input.args )#
	if(length(tmp2)>0)#
	{#
		stop('Found invalid arguments,',input.args[tmp2])#
	}	#
	#	for all character arguments: add encapsulating "" #
	#	for all logical arguments that evaluate to TRUE: keep only the name#
	for(ii in seq_along(input.args))#
	{#
		if(is.character(input.args[[ii]]) && !substr(input.args[[ii]],1,1)%in%c("'",'"'))#
			input.args[[ii]] <- paste0('"',input.args[[ii]],'"')#
		if(is.logical(input.args[[ii]]) && input.args[[ii]])#
			input.args[[ii]] <- ''#
	}	#
	#	sort arguments by name#
	tmp			<- sort(names(input.args), index.return=TRUE)$ix#
	input.args	<- input.args[tmp]#
	##
	#	make command#
	##
	#	create local tmp dir#
	cmd		<- paste("CWD=$(pwd)\n",sep='\n')#
	cmd		<- paste(cmd,"echo $CWD\n",sep='')#
	tmpdir	<- paste('pty','_',format(Sys.time(),"%y-%m-%d-%H-%M-%S"),sep='')	#
	tmpdir	<- paste("$CWD/",tmpdir,sep='')#
	cmd		<- paste(cmd,'mkdir -p "',tmpdir,'"\n',sep='')#
	#	if tree.input is zip file, extract and change tree.input to directory#
	if(grepl('\\.zip$',tree.input))#
	{		#
		tree.dir	<- gsub('\\.zip$','',file.path(tmpdir,basename(tree.input)))#
		cmd			<- paste(cmd,'mkdir -p "',tree.dir,'"\n',sep='')#
		cmd			<- paste(cmd,'unzip -j "',tree.input,'" -d "',tree.dir,'"\n',sep='')#
		#	passing directory is currently not supported, must pass base of tree file names before the window coordinates start#
		#	determine prefix of tree files via control$tree.file.regex#
		#	the regex must contain ()#
		if( !grepl('\\(',control$tree.file.regex) )#
			stop('Cannot make tree.input variable, expect control$tree.file.regex with () that identify window coordinates, found:',control$tree.file.regex)	#
		tmp				<- unzip(tree.input, list=TRUE)		#
		tmp$windowid	<- gsub(control$tree.file.regex, '\\1', tmp$Name)#
		tmp$prefix		<- sapply(seq_along(tmp$Name), function(x) gsub(paste0(tmp$windowid[x],'.*'),'',tmp$Name[x]))		#
		if( !all( tmp$prefix==tmp$prefix[1] ) )#
			stop('Cannot make tree.input variable, contact maintainer', tmp$Name)		#
		tree.input	<- file.path(tree.dir,tmp$prefix[1])#
	}	#
	#	add encapsulating "" to tree.input#
	if(!substr(tree.input,1,1)%in%c("'",'"'))#
		tree.input	<- paste0('"',tree.input,'"')#
	#	cd to tmp dir#
	cmd		<- paste(cmd, 'cd "',tmpdir,'"\n', sep='')	#
	#	add call with positional arguments#
	cmd		<- paste(cmd, prog.phyloscanner_analyse_trees,' ',tree.input,' ',output.string,' ',splits.rule, sep='')#
	#	add optional arguments#
	for(ii in seq_along(input.args))#
	{#
		cmd			<- paste0(cmd,' --',names(input.args)[[ii]])#
		if(input.args[[ii]]!='')#
			cmd		<- paste0(cmd,' ',input.args[[ii]])#
	}#
	#	copy to outdir#
	cmd		<- paste(cmd, '\nmv ',output.string,'_workspace.rda "',out.dir,'"\n',sep='')#
	#	remove trees directory#
	if(exists('tree.dir'))#
		cmd		<- paste0(cmd, 'rm -rf ',tree.dir,'\n')#
	#	zip up everything else#
	cmd		<- paste(cmd, 'for file in *; do\n\tzip -ur9XTjq ',paste(output.string,'_otherstuff.zip',sep=''),' "$file"\ndone\n',sep='')#
	cmd		<- paste(cmd, 'mv ',paste(output.string,'_otherstuff.zip',sep=''),' "',out.dir,'"\n',sep='')#
	#	clean up#
	cmd		<- paste(cmd,'cd $CWD\nrm -rf "',tmpdir,'"\n',sep='')#
	cmd#
}
prog.phyloscanner_analyse_trees <- '/Users/Oliver/git/phyloscanner/phyloscanner_analyse_trees.R'#
	valid.input.args 				<- cmd.phyloscanner_analyse_trees.valid.args(prog.phyloscanner_analyse_trees)#
	cmds							<- vector('list',nrow(df))#
	for(i in seq_len(nrow(df)))#
	{#
		#	set input args#
		control$output.string 	<- paste0('ptyr',df[i,RUN])	#
		#	make script#
		tree.input				<- file.path(indir, df[i, TREES_NEWICK])#
		cmd						<- cmd.phyloscanner_analyse_trees(prog.phyloscanner_analyse_trees, #
				tree.input, #
				control,#
				valid.input.args=valid.input.args)#
		cmds[[i]]				<- cmd		#
	}	#
	cat(cmds[[100]])
library(RCurl)
tmp <- "https://datadryad.org/bitstream/handle/10255/dryad.208474/Dataset_S2.csv?sequence=2"#
	x 	<- getURL(tmp)
x
?getURL
tmp <- "https://datadryad.org/bitstream/handle/10255/dryad.208474/Dataset_S2.csv?sequence=2"#
	download.file(tmp, destfile = "Dataset_S2.csv", method="curl")
tmp <- "https://datadryad.org/bitstream/handle/10255/dryad.208473/Dataset_S1.tar?sequence=1"#
	download.file(tmp, destfile = "Dataset_S1.tar", method="curl")
tree.dir <- "RakaiPopSample_deepseqtrees"
untar("Dataset_S1.tar", exdir=tree.dir, extras='-xvf')
untar("Dataset_S1.tar", exdir=tree.dir, extras='-xv')
df <- tibble(F=list.files(tree.dir))#
	df <- df %>% #
			mutate(TYPE:= gsub('ptyr([0-9]+)_(.*)','\\2', F),#
					RUN:= as.integer(gsub('ptyr([0-9]+)_(.*)','\\1', F))) %>%#
			mutate(TYPE:= gsub('^([^\\.]+)\\.[a-z]+$','\\1',TYPE)) %>%#
			spread(TYPE, F) %>%#
			set_names(~ str_to_upper(.))
require(tidyr)
df <- tibble(F=list.files(tree.dir))#
	df <- df %>% #
			mutate(TYPE:= gsub('ptyr([0-9]+)_(.*)','\\2', F),#
					RUN:= as.integer(gsub('ptyr([0-9]+)_(.*)','\\1', F))) %>%#
			mutate(TYPE:= gsub('^([^\\.]+)\\.[a-z]+$','\\1',TYPE)) %>%#
			spread(TYPE, F) %>%#
			set_names(~ str_to_upper(.))
require(tidyverse)
df <- tibble(F=list.files(tree.dir))#
	df <- df %>% #
			mutate(TYPE:= gsub('ptyr([0-9]+)_(.*)','\\2', F),#
					RUN:= as.integer(gsub('ptyr([0-9]+)_(.*)','\\1', F))) %>%#
			mutate(TYPE:= gsub('^([^\\.]+)\\.[a-z]+$','\\1',TYPE)) %>%#
			spread(TYPE, F) %>%#
			set_names(~ str_to_upper(.))
df
valid.input.args <- cmd.phyloscanner_analyse_trees.valid.args(prog.phyloscanner_analyse_trees)#
	cmds <- vector('list',nrow(df))#
	for(i in seq_len(nrow(df)))#
	{#
		#	set input args#
		control$output.string <- paste0('ptyr',df$RUN[i])	#
		#	make script#
		tree.input <- file.path(indir, df$TREES_NEWICK[i])#
		cmd <- cmd.phyloscanner_analyse_trees(prog.phyloscanner_analyse_trees, #
				tree.input, #
				control,#
				valid.input.args=valid.input.args)#
		cmds[[i]] <- cmd		#
	}	#
	cat(cmds[[100]])
require(roxygen2)
roxygenise('~/git/phyloscanner/phyloscannerR')
indir	<- '~/Dropbox (SPH Imperial College)/2015_PANGEA_DualPairsFromFastQIVA/RakaiAll_input_170301'
z<- load(file.path(indir,'Rakai_phyloscanner_170301_assemblystatus.rda'))
z
dc
subset(dc, !is.na(SID))
z<- load('~/Dropbox (SPH Imperial College)/2015_PANGEA_DualPairsFromFastQIVA/RakaiAll_input_170301/Rakai_phyloscanner_170704_assemblystatus.rda')
z
dc
subset(dc, !is.na(SID))
table(dc$IMPERIAL_LEN)
require(data.table)
indir	<- '~/Box Sync/OR_Work/MSCs/2019_Melodie'#
	infile.couples <- file.path(indir,'analyses','190611_phsccouples.rda')	#
	load(infile.couples)
rca
unique(c( rca[, MALE_RID], rca[, FEMALE_RID] ))
write.csv( data.table(RID=sort( unique(c( rca[, MALE_RID], rca[, FEMALE_RID] )) )), row.names=FALSE, file=file.path(indir,'analyses','190611_phsccouples_NeedInfTimes.csv'))
require(data.table)#
	require(tidyverse)#
	require(ape)#
	require(phytools)#
	#	locally#
	if(1)#
	{#
		indir	<- '~/Box Sync/OR_Work/MSCs/2019_Melodie'#
		infile.couples <- file.path(indir,'analyses','190611_phsccouples.rda')	#
		rel.dir <- "~/sandbox/DeepSeqProjects/RakaiPopSample_phyloscanner_analysis"#
	}#
	df <- tibble(F=list.files(rel.dir))
df
df <- tibble(F=list.files(rel.dir))#
	df <- df %>% #
			filter(grepl('pairwise_relationships.rda',F))
df
df <- tibble(F=list.files(rel.dir)) %>% #
			filter(grepl('pairwise_relationships.rda',F))#
			mutate(PTY_RUN:= as.integer(gsub('ptyr([0-9]+)_(.*)','\\1', F)))
df <- tibble(F=list.files(rel.dir)) %>% #
			filter(grepl('pairwise_relationships.rda',F)) %>%#
			mutate(PTY_RUN:= as.integer(gsub('ptyr([0-9]+)_(.*)','\\1', F)))
df
#	load couples and select those between whom we want to compute tip-to-tip distances#
	load(infile.couples)#
	set(rca, NULL, 'MALE_ARID', as.character(rca$MALE_ARID))#
	set(rca, NULL, 'FEMALE_ARID', as.character(rca$FEMALE_ARID))#
	rcl	<- subset(rca, grepl('most likely',SELECT))#
	#	select phyloscanner runs with linked couples#
	tmp	<- unique(subset(rcl, select=PTY_RUN))
tmp
df	<- merge(tmp, as.data.table(df), by='PTY_RUN')
df
run	<- 5
run	<- 5	#for devel#
		tmpfile	<-  subset(df,PTY_RUN==run)[,file.path(rel.dir, F)]
tmpfile
z<- load(tmpfile)
z
dwin
dwin <- subset(dwin, select=c(SUFFIX, W_FROM, W_TO, ID1, ID2, ADJACENT, CONTIGUOUS, PATHS_12, PATHS_21))
dwin
df
rcl
dwin
dwin[, ID1_GENDER:= gsub('.*([MF])$','\\1',ID1)]
dwin
dwin[, ID2_GENDER:= gsub('.*([MF])$','\\1',ID2)]
dwin
dwin[, table(ID1_GENDER, ID2_GENDER)]
subset(dwin, ID1_GENDER=='F' & ID2_GENDER=='M'  |   ID1_GENDER=='M' & ID2_GENDER=='F')
dwin <- subset(dwin, ID1_GENDER=='F' & ID2_GENDER=='M'  |   ID1_GENDER=='M' & ID2_GENDER=='F')
dwin
rcl
dwin
tmp	<- subset(dwin, ID1_GENDER=='F' & ID2_GENDER=='M')
tmp
setnames(tmp, c('ID1','ID2','PATHS_12','PATHS_21','ID1_GENDER','ID2_GENDER'), c('ID2','ID1','PATHS_21','PATHS_12','ID2_GENDER','ID1_GENDER'))
tmp
dwin	<- rbind( subset(dwin, ID1_GENDER=='M' & ID2_GENDER=='F'), tmp)
dwin
rcl
tmp	<- data.table(ID1= rcl$MALE_ARID, ID2= rcl$FEMALE_ARID)
tmp
dwin	<- merge(tmp, dwin, by=c('ID1','ID2'))
dwin
df
ans	<- vector('list', 0)#
	for(run in df$PTY_RUN)#
	{#
		#run	<- 5	#for devel#
		#	load relationship file and extract basic statistics for all windows#
		tmpfile	<-  subset(df,PTY_RUN==run)[,file.path(rel.dir, F)]#
		load(tmpfile)#
		dwin 	<- subset(dwin, select=c(SUFFIX, W_FROM, W_TO, ID1, ID2, ADJACENT, CONTIGUOUS, PATHS_12, PATHS_21))#
		dwin[, ID1_GENDER:= gsub('.*([MF])$','\\1',ID1)]#
		dwin[, ID2_GENDER:= gsub('.*([MF])$','\\1',ID2)]#
		dwin 	<- subset(dwin, ID1_GENDER=='F' & ID2_GENDER=='M'  |   ID1_GENDER=='M' & ID2_GENDER=='F')#
		tmp		<- subset(dwin, ID1_GENDER=='F' & ID2_GENDER=='M')#
		setnames(tmp, c('ID1','ID2','PATHS_12','PATHS_21','ID1_GENDER','ID2_GENDER'), c('ID2','ID1','PATHS_21','PATHS_12','ID2_GENDER','ID1_GENDER'))#
		dwin	<- rbind( subset(dwin, ID1_GENDER=='M' & ID2_GENDER=='F'), tmp)#
		#	select couples#
		tmp		<- data.table(ID1= rcl$MALE_ARID, ID2= rcl$FEMALE_ARID)#
		dwin	<- merge(tmp, dwin, by=c('ID1','ID2'))#
		#	return#
		dwin[, PTY_RUN:= run]#
		ans[[length(ans)+1L]]	<- copy(dwin)#
	}
str(ans)
rcl
ans	<- do.call('rbind', ans)
ams
ans
setkey(ans, PTY_RUN, ID1, ID2)
ans
write.csv(ans, row.names=FALSE, file==file.path(indir,'analyses','190611_phsccouples_basic_topology_stats.csv'))
write.csv(ans, row.names=FALSE, file=file.path(indir,'analyses','190611_phsccouples_basic_topology_stats.csv'))
require(roxygen2)#
	code.dir	<- '~/git/phylonetworks'#
	roxygenize(code.dir)
require(roxygen2)#
	code.dir	<- '~/git/phylonetworks'#
	roxygenize(code.dir)
105,321.36/2
105321.36/2
Ft<- 1e3
F2<- 1e2:1e4
df<- data.table(F= 1e3, F2= 1e2:1e4)
df
df[, P:= ( abs(F2-F)/F * 2 * pi )%% (2*pi)]
df
ggplot(df, aes(x=F, y=P)) + geom_line()
ggplot(df, aes(x=F2, y=P)) + geom_line()
df[, PY:= (F2/F * 2*pi) %% (2*pi)]
df
df[, PR:= abs(sin(pmax(F/F2, F2/F)*pi ))]
df
melt(df, id.vars=c('F','F2'))
ggplot( melt(df, id.vars=c('F','F2')), aes(x=F2, y=value, colour=variable)) + geom_line()
ggplot( melt(df, id.vars=c('F','F2')), aes(x=F2, y=value, colour=variable)) + geom_line() + scale_x_continuous(breaks=c(0,100,500,1e3,2e3,3e3,4e3))
ggplot( melt(df, id.vars=c('F','F2')), aes(x=F2, y=value, colour=variable)) + geom_line() + log2(breaks=c(0,100,500,1e3,2e3,3e3,4e3))
ggplot( melt(df, id.vars=c('F','F2')), aes(x=F2, y=value, colour=variable)) + geom_line() + log2(breaks=c(100,500,1e3,2e3,3e3,4e3))
ggplot( melt(df, id.vars=c('F','F2')), aes(x=F2, y=value, colour=variable)) + geom_line() + scale_x_log2(breaks=c(100,500,1e3,2e3,3e3,4e3))
ggplot( melt(df, id.vars=c('F','F2')), aes(x=F2, y=value, colour=variable)) + geom_line() + scale_x_continuous(trans='log2', breaks=c(100,500,1e3,2e3,3e3,4e3))
c(21,24,29,38)/60
c(21,24,29,38)/60 * 1.5
c(21,24,29,38)/60 * 1.2
c(21,24,29,38)/60 * 1.1
c(21,24,29,38)/60 * 1.2
c(21,24,29,38)/60 +5
c(21,24,29,38)/60 +.05
(c(21,24,29,38)+5)/60
(c(21,24,29,38)+4)/60
(c(21,24,29,38)+3)/60
sqrt(c(0.4,0.6))
c(0.4,0.6^(1/2))
c(0.4,0.6)^(1/2)
c(0.4,0.6)^(1/3)
c(0.4,0.6)^(1/1.8)
c(0.4,0.6)^(1/1.6)
c(0.4,0.6)^(1/1.5)
c(0.4,0.6)^(1/1.4)
( c(21,24,29,38)/60 )^(1/1.4)
( c(21,24,29,38)/60 )^(1/1.3)
( c(21,24,29,38)/60 )^(1/1.1)
( c(21,24,29,38)/60 )^(1/1.2)
( c(21,24,29,38)^(1/1.2) / 60 )
( c(21,24,29,38)^(2) / 60 )
( c(21,24,29,38)^(1.2) / 60 )
( c(21,24,29,38)^(1.1) / 60 )
( c(21,24,29,38)^(1.01) / 60 )
( c(21,24,29,38)^(1.0) / 60 )
( c(21,24,29,38)/60 )^(1/1.2)
( (c(21,24,29,38)+5)/60 )^(1/1.2)
( (c(21,24,29,38)+5)/60 )^(1/1)
( (c(21,24,29,38)+3)/60 )^(1/1)
( (c(21,24,29,38)+3)/60 )^(1/1.2)
( (c(21,24,29,38)+3)/60 )^(1/1.3)
( (c(21,24,29,38)-3)/60 )^(1/1.3)
( (c(21,24,29,38)-3)/60 )^(1/1.4)
( (c(21,24,29,38)-3)/60 )^(1/1.5)
( (c(21,24,29,38)-3)/60 )^(1/1.6)
( (c(21,24,29,38)-3)/60 )^(1/1.7)
( (c(21,24,29,38)-3)/60 )^(1/1.8)
( (c(21,24,29,38)-5)/60 )^(1/2)
( (c(21,24,29,38)-8)/60 )^(1/2)
( (c(21,24,29,38))/60 )^(1/1.5)
exp( 0.4 )
exp( -0.4 )
c(21,24,29,38)/60
exp(- c(21,24,29,38)/60 )
exp( c(21,24,29,38)/60 )
exp( c(21,24,29,38)/60 * 0.5)
exp( c(21,24,29,38)/60 * 0.1)
( c(21,24,29,38)/60 )^(1/1.2)
( (1+c(21,24,29,38))/60 )^(1/1.2)
( (2+c(21,24,29,38))/60 )^(1/1.2)
( (3+c(21,24,29,38))/60 )^(1/1.2)
( (4+c(21,24,29,38))/60 )^(1/1.2)
( c(21,24,29,38)/60 )^(1/1.3)
( c(21,24,29,38)/60 )^(1/1.4)
( c(21,24,29,38)/60 )^(1/1.5)
require(pkddown)
require(pkgdown)
build_site('~/git/phyloscanner/phyloflows')
setwd('/Users/Oliver/git/phyloscanner/phyloflows')
build_site()
install_github("BDI-pathogens/phyloscanner/phyloflows", dependencies=TRUE, build_vignettes=FALSE)#
require(phyloflows)
require(devtools)
install_github("BDI-pathogens/phyloscanner/phyloflows", dependencies=TRUE, build_vignettes=FALSE)
require(phyloflows)
require(ggplot2)#
require(bayesplot)#
require(data.table)#
require(coda)#
#
data(twoGroupFlows1, package="phyloflows")#
dobs <- twoGroupFlows1$dobs#
dprior <- twoGroupFlows1$dprior
dprior
dobs
control <- list(seed=42, mcmc.n=500, verbose=0)#
ans <- phyloflows:::source.attribution.mcmc(dobs, dprior, control)
