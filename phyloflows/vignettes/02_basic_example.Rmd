---
title: "02 - Very first example"
date: "2019-04-30"
output: github_document
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
```{r, include=TRUE, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, tidy=TRUE}
require(knitr)
require(kableExtra)
```
```{r, include=FALSE, eval=FALSE, echo=FALSE}
require(rmarkdown)
setwd('/Users/Oliver/git/phyloscanner/phyloflows/vignettes')
infile <- '02_basic_example.Rmd'
rmarkdown::render(infile)

rmarkdown::render(infile, output_format='pdf_document')	
```


This vignette gives a basic first introduction to estimating transmission flows
with the `phyloflows` package. Please read the sections "Our Job" and "Our
Solution" on the main page before you go ahead here.


# Input data
**phyloflows** expects input data in a specific format. 

* `dobs` a data.frame of observed transmission counts within and between
  population groups. 
* `dprior` a data.frame that summarises prior information on how
  population groups were sampled. 

To get you started, **phyloflows** comes with a small simulated example data set
of transmission counts and sampling information between two population groups,
denoted by "1" and "2":
```{r, include=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE, message=FALSE, warning=FALSE}
#	required R packages
require(phyloflows)
require(ggplot2)
require(bayesplot)
require(data.table)
require(coda)

#
#	load transmission flow data "twoGroupFlows1"
data(twoGroupFlows1, package="phyloflows")
#	observed transmission counts
dobs <- twoGroupFlows1$dobs
#	sampling information
dprior <- twoGroupFlows1$dprior
```

## Input data: observed transmission flows
```{r, include=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE}
dobs
```
**`dobs` specifies observed counts of transmissions from a
transmitter group to a recipient group.** It must contain the following columns:
 
* *TR_TRM_CATEGORY* name of transmitter group.
* *REC_TRM_CATEGORY* name of recipient group.
* *TRM_CAT_PAIR_ID* identifier of transmitter-recipient pair
* *TRM_OBS* observed transmission counts

Let us look at the data. The first row contains counts of transmission
flows from group "1" to group "1", and there are 139 of them. The next row
contains counts of transmission flows from group "1" to group "2", and there are
15 of them. Here is a barplot of our input data: 
```{r, include=TRUE, eval=TRUE, echo=FALSE, tidy=FALSE, fig.dim = c(8, 3), fig.align="center"}
ggplot(dobs, aes(x=paste0(TR_TRM_CATEGORY,'->',REC_TRM_CATEGORY), y=TRM_OBS, fill=paste0(TR_TRM_CATEGORY,'->',REC_TRM_CATEGORY))) +
		geom_bar(stat='identity') +
		guides(fill='none') +
		theme_classic() +
		labs(x='transmission flows\n(from -> to)\n', y='\nobserved counts') +
		coord_flip()
```

## Input data: sampling information
**`dobs` also must contain information about how each group was sampled.** This
is stored in the following columns: 
  
* *TR_SAMPLING_CATEGORY* sampling strata of transmitter group
* *REC_SAMPLING_CATEGORY* sampling strata of recipient group


Each transmitter/recipient group is associated to a sampling category. This can
be "sampling group a" for both "1" and "2", or "a" and "b" respectively for "1"
and "2". In our little data set, we gave the same name to transmitter/recipient
and sampling groups. 

**`dprior` specifies the probability of sampling
an individual from each sampling group.** To keep this as flexible as possible,
samples from the sampling distribution, rather than say the mean and standard
deviation, need to be given. This information is stored in the following 
columns: 

* *SAMPLING_CATEGORY* name of sampling strata
* *SAMPLE* identifier of sample from the sampling distribution
* *P* sampling probability
* *LP* log density of the sampling probability under the sampling distribution.

Let us look at the sampling information: 
```{r, include=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE}
head(dprior)
```

Here is a histogram of the sampling distribution from sampling groups "1" and
"2". Notice that in our example, the probability of sampling individuals in
group "1" is higher than that among individuals in group "2".


```{r, include=TRUE, eval=TRUE, echo=FALSE, tidy=FALSE, warning=FALSE,  fig.dim = c(8, 5), fig.align="center"}
ggplot(dprior, aes(x=P)) +
		geom_histogram(binwidth=0.005, alpha=0.5, fill='deepskyblue4') +
		theme_bw() +
		labs(x='\nsampling distribution in group 1 and 2', y='observed counts\n') +
		scale_x_continuous(labels=scales:::percent, lim=c(0.4,0.7), expand=c(0,0)) +
		facet_grid(~SAMPLING_CATEGORY)
```

# phyloflows MCMC algorithm
## Statistical model
`phyloflows` uses a Bayesian approach to estimate the proportion of
transmissions between the two population groups,
$$
\pi=(\pi_{11}, \pi_{12}, \pi_{21}, \pi_{22}).
$$ 
The model can be motivated as follows. Suppose the actual, unobserved number of
transmissions from group $i$ to group $j$ are $z_{ij}$. Denote the vector of
actual transmission counts by
$$
z=(z_{11}, z_{12}, z_{21}, z_{22}).
$$ 
The likelihood of the actual transmission counts is then given by
$$
p(z|Z,\pi)= Multinomial(z;Z,\pi),
$$
where $Z$ is the total number of transmissions, $Z=\sum_{kl} z_{kl}$, if we
assume that transmission events occurred independently of each other. Next, we
specify a model for observing one actual transmission event. This is given by
$$
p(n_{ij}|z_{ij},s_i,s_j)= Binomial(n_{ij};z_{ij},s_i*s_j),
$$
where $s_i$ is the probability of sampling an individual from group $i$, and
similary for $s_i$. The free parameters of the model are
$$
\theta= (z, Z, \pi, s),
$$
and the posterior distribution of the free parameters is given by 
$$
\begin{aligned}
p(\theta | n) & \propto p(n | \theta) p(\theta) \\
              & = \prod_{ij} Bin(n_{ij};z_{ij},s_i*s_j)  Multin(z;Z,\pi) p(Z) p(\pi) p(s).
\end{aligned}
$$
In general we specify for 

* $p(\pi)$ an uninformative prior distribution (Dirichlet distribution with parameters $0.8/4$);
* $p(s)$ a strongly informative prior distribution, based on available data (as illustrated above);
* $p(Z)$ a strongly informative prior distribution, based on available data (Poisson distribution with mean set to the expected number of actual transmissions).

## MCMC: syntax 
To sample from the posterior distribution
$$
p(z, Z, \pi, s | n),
$$
we use a Markov Chain Monte Carlo algorithm. The syntax for running the
algorithm is as follows. 
```{r, include=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE, message=TRUE}
# specify a list of control variables:
#	seed  	random number seed
#	mcmc.n 	number of MCMC iterations
#	verbose flag for verbose output
#	outfile output file name if you like to have the results 
#			written to an *.rda* file
control <- list(seed=42, mcmc.n=500, verbose=0,sweep_group=125L)
# run MCMC
ans <- source.attribution.mcmc(dobs, dprior, control)
```

## MCMC: messages
Let s have a look at the messages first. 

* The total number of unknown parameters in **phyloflows** MCMC is the length of
  $\pi$ plus the length of the latent transmission flows $z$ plus the
  length of the pairwise sampling probabilities $\xi$, $\xi_{ij}=s_i*s_j$, 
  plus twice the length of the sampling probabilities $s$, plus 1 for $Z$.
  This makes $4+4+4+2*2+1=17$ in our very first example.
* The MCMC updates all these parameters in a certain number of MCMC iterations,
  and this number is called a sweep. A sweep is always twice the length of the
  sampling probabilities plus 1 for updating the values of $\pi$. This makes $2*2+1$ 
  in our very first example.
* The total number of sweeps is determined from `control[['mcmc.n']]`. In our
  case, it is $50/5=10$. If we had set `control[['mcmc.n']]<- 51`, then the total number 
  of sweeps would have been $11$.
* The total number of iterations is the length of a sweep times the total
  number of sweeps. In our example, $5*10=50$.  If we had set `control[['mcmc.n']]<- 51`, 
  then the total number of iterations would have been $5*11=55$.
* Finally, we have the number of transmission pair categories updated per
  iteration. These numbers are important to assess the likely performance of
  the MCMC. The algorithm proceeds by updating the sampling probabilities for
  the transmitter groups, then those for the recipient groups, and finally one
  update for the values of $\pi$. If we update $s_1$ for the transmitter groups, 
  we also need to update all pairwise sampling probabilities that
  contain $s_1$ for the transmitter groups. These are $\xi_{11}=s_1*s_1$ and $\xi_{12}=s_1*s_2$,
  so we have two pairwise sampling probabilities to update. In our very
  first example, this is always the case: if we update any of the 4 $s_i$ for
  either the transmitter and recipient groups, we always have to update 2
  pairwise sampling probabilities. This is what you see printed, before the
  algorithm gets cranking. In general, the fewer pairwise sampling
  probabilities need to be updated, the better, because the MCMC acceptance 
  rates take a huge hit when many parameters need to be updated at once. Set up
  your model so that you have at most 4-6 joint parameter updates at any MCMC
  iteration.

## MCMC: output

Let us have a look at the output:  
```{r, include=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE, message=TRUE}
str(ans)
```

We are mostly interested in the joint posterior distribution 
$$
p(\pi | n ),
$$ 
which is just a component of the entire posterior distribution of all 
parameters
$$
p(\pi, z, Z, \xi, s | n ).
$$

So let us look at just this component in the output, and make a trace
plot:      
```{r, include=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE, message=TRUE, fig.dim = c(8, 6), fig.align="center"}
post.pi <- ans[['pars']][['PI']]
colnames(post.pi) <- paste0('PI-',1:ncol(post.pi))
bayesplot:::mcmc_trace(post.pi, pars=colnames(post.pi), facet_args = list(ncol = 1), n_warmup=0)
```
  
Ok, fab. Of course we would like many more iterations, perhaps $10,000$ sweeps are a good number. 
We can do that. But what really are *PI-1*, *PI-2*, *PI-3*, *PI-4*? The numbers
1-4 are just the values of the transmission pair IDs in
`dobs`, `dobs$TRM_CAT_PAIR_ID`. So we can associate more interpretable names
to the output as follows: 
```{r, include=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE, message=TRUE, fig.dim = c(8, 6), fig.align="center"} 
post.pi <- ans[['pars']][['PI']]
setkey(dobs, TRM_CAT_PAIR_ID) #order by pair IDs
post.pi.colnames <- paste0('PI ',dobs$TR_TRM_CATEGORY,'->',dobs$REC_TRM_CATEGORY)
colnames(post.pi) <- post.pi.colnames
bayesplot:::mcmc_trace(post.pi, pars=colnames(post.pi), facet_args = list(ncol = 1), n_warmup=0)
```

That's it for now. Use your usual R wizadry to process the output further, and
have a look at the other vignettes.

