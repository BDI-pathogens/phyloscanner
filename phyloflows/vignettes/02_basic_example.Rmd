---
title: "02 - Very first example"
date: "2019-04-30"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
```{r, include=TRUE, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, tidy=TRUE}
require(knitr)
require(kableExtra)
```


Here is a very first example data set for you to have a go at. Please read the
sections [Our Job](index.html) and [Our Solution](index.html) on the main
page before you go ahead here.


# Input data
**phyloflows** expects input data in a specific format. First, a data.frame
of observed transmission counts within and between population groups, which we
call `dobs`. Second a data.frame that summarises prior information on how
population groups were sampled, which we call `dprior`. 

To get you started, **phyloflows** comes with a small simulated example data set
of transmission counts and sampling information between two population groups,
denoted by "1" and "2":
```{r, include=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE, message=FALSE, warning=FALSE}
require(phyloflows)
require(ggplot2)
require(bayesplot)
require(data.table)
require(coda)

data(twoGroupFlows1, package="phyloflows")
dobs <- twoGroupFlows1$dobs
dprior <- twoGroupFlows1$dprior
```

## Input data: observed transmission flows
```{r, include=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE}
dobs
```
Data.frame `dobs` must contain the columns *TR_TRM_CATEGORY*,
*REC_TRM_CATEGORY*, *TRM_CAT_PAIR_ID*, and *TRM_OBS*. Each row specifies
observed counts of transmissions from a transmitter group to a recipient group.
Each combination of transmission flows is given an ID, and that ID is stored in
*TRM_CAT_PAIR_ID*. `dobs` also must contain the columns *TR_SAMPLING_CATEGORY*
and *REC_SAMPLING_CATEGORY*, which associate each transmitter/recipient group
with a sampling category. We will get to this in a minute. For now, let us look
at the data.frame. The first row contains counts of transmission flows from
group "1" to group "1", and there are 139 of them. The next row contains
counts
of transmission flows from group "1" to group "2", and there are 15 of
them. Here is a barplot of our input data: 

```{r, include=TRUE, eval=TRUE, echo=FALSE, tidy=FALSE, fig.dim = c(8, 3), fig.align="center"}
ggplot(dobs, aes(x=paste0(TR_TRM_CATEGORY,'->',REC_TRM_CATEGORY), y=TRM_OBS, fill=paste0(TR_TRM_CATEGORY,'->',REC_TRM_CATEGORY))) +
		geom_bar(stat='identity') +
		guides(fill='none') +
		theme_classic() +
		labs(x='transmission flows\n(from -> to)\n', y='\nobserved counts') +
		coord_flip()
```

## Input data: sampling information
Each transmitter/recipient group is associated to a sampling category. This can
be "sampling group a" for both "1" and "2", or "a" and "b" respectively for "1"
and "2". In our little data set, we gave the same name to transmitter/recipient
and sampling groups. Data.frame `dprior` specifies the probability of sampling
an individual from each sampling group. To keep this as flexible as possible,
samples from the sampling distribution, rather than say the mean and standard
deviation, need to be given. Data.frame `dprior` must contain the columns
*SAMPLING_CATEGORY*, *SAMPLE*, *P* and *LP*. *SAMPLING_CATEGORY* specifies the
sampling group; *SAMPLE* is just an ID specifying if it is the first, second,
... sample; *P* is the value of the sample, and *LP* is the log density of the
sample.

```{r, include=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE}
head(dprior)
```

Here is a histogram of the sampling distribution from sampling groups "1" and
"2". Notice that in our example, the probability of sampling individuals in
group "1" is higher than that among individuals in group "2".


```{r, include=TRUE, eval=TRUE, echo=FALSE, tidy=FALSE, warning=FALSE,  fig.dim = c(8, 3), fig.align="center"}
ggplot(dprior, aes(x=P)) +
		geom_histogram(binwidth=0.005, alpha=0.5, fill='deepskyblue4') +
		theme_classic() +
		labs(x='\nsampling probabilities per sampling group', y='observed counts\n') +
		scale_x_continuous(labels=scales:::percent, lim=c(0,1), expand=c(0,0)) +
		facet_grid(~SAMPLING_CATEGORY)
```

# phyloflows MCMC algorithm
## MCMC: syntax 
Now that we understand the input data, we are ready to estimate the
transmission flows within and between the two population groups,
$$
\pi=(\pi_{11}, \pi_{12}, \pi_{21}, \pi_{22}).
$$ 
We just need to specify a seed, number of iterations of the Markov
Chain Monte Carlo algorithm, a flag for verbose output, and an output file name
if you like to have the results written to an *.rda* file.

```{r, include=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE, message=TRUE}
control <- list(seed=42, mcmc.n=500, verbose=0)
ans <- phyloflows:::source.attribution.mcmc(dobs, dprior, control)
```

## MCMC: messages
Let s have a look at the messages first. 

* The total number of unknown parameters in **phyloflows** MCMC is the length of
  \(\pi\) plus the length of the latent transmission flows \(z\) plus the
  length of the pairwise sampling probabilities \(\xi\), \(\xi_{ij}=s_i*s_j\), 
  plus twice the length of the sampling probabilities \(s\), plus 1 for \(Z\).
  This makes \(4+4+4+2*2+1=17\) in our very first example.
* The MCMC updates all these parameters in a certain number of MCMC iterations,
  and this number is called a sweep. A sweep is always twice the length of the
  sampling probabilities plus 1 for updating the values of \(\pi\). This makes \(2*2+1\) 
  in our very first example.
* The total number of sweeps is determined from `control[['mcmc.n']]`. In our
  case, it is \(50/5=10\). If we had set `control[['mcmc.n']]<- 51`, then the total number 
  of sweeps would have been \(11\).
* The total number of iterations is the length of a sweep times the total
  number of sweeps. In our example, \(5*10=50\).  If we had set `control[['mcmc.n']]<- 51`, 
  then the total number of iterations would have been \(5*11=55\).
* Finally, we have the number of transmission pair categories updated per
  iteration. These numbers are important to assess the likely performance of
  the MCMC. The algorithm proceeds by updating the sampling probabilities for
  the transmitter groups, then those for the recipient groups, and finally one
  update for the values of \(\pi\). If we update \(s_1\) for the transmitter groups, 
  we also need to update all pairwise sampling probabilities that
  contain \(s_1\) for the transmitter groups. These are \(\xi_{11}=s_1*s_1\) and \(\xi_{12}=s_1*s_2\),
  so we have two pairwise sampling probabilities to update. In our very
  first example, this is always the case: if we update any of the 4 \(s_i\) for
  either the transmitter and recipient groups, we always have to update 2
  pairwise sampling probabilities. This is what you see printed, before the
  algorithm gets cranking. In general, the fewer pairwise sampling
  probabilities need to be updated, the better, because the MCMC acceptance 
  rates take a huge hit when many parameters need to be updated at once. Set up
  your model so that you have at most 4-6 joint parameter updates at any MCMC
  iteration.

## MCMC: output

Let us have a look at the output:  
```{r, include=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE, message=TRUE}
str(ans)
```

We are mostly interested in the joint posterior distribution 
$$
p(\pi | n ),
$$ 
which is just a component of the entire posterior distribution of all 
parameters
$$
p(\pi, z, Z, \xi, s | n ).
$$

So let us look at just this component in the output, and make a trace
plot:      
```{r, include=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE, message=TRUE, fig.dim = c(8, 6), fig.align="center"}
post.pi <- ans[['pars']][['PI']]
colnames(post.pi) <- paste0('PI-',1:ncol(post.pi))
bayesplot:::mcmc_trace(post.pi, pars=colnames(post.pi), facet_args = list(ncol = 1), n_warmup=0)
```
  
Ok, fab. Of course we would like many more iterations, perhaps \(10,000\) sweeps are a good number. 
We can do that. But what really are *PI-1*, *PI-2*, *PI-3*, *PI-4*? The numbers
1-4 are just the values of the transmission pair IDs in
`dobs`, `dobs$TRM_CAT_PAIR_ID`. So we can associate more interpretable names
to the output as follows: 
```{r, include=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE, message=TRUE, fig.dim = c(8, 6), fig.align="center"} 
post.pi <- ans[['pars']][['PI']]
setkey(dobs, TRM_CAT_PAIR_ID) #order by pair IDs
post.pi.colnames <- paste0('PI ',dobs$TR_TRM_CATEGORY,'->',dobs$REC_TRM_CATEGORY)
colnames(post.pi) <- post.pi.colnames
bayesplot:::mcmc_trace(post.pi, pars=colnames(post.pi), facet_args = list(ncol = 1), n_warmup=0)
```

That's it for now. Use your usual R wizadry to process the output further, and
have a look at the other vignettes.

