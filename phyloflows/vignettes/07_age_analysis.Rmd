---
title: "07 - Age analysis"
date: "2019-12-10"
author: Xiaoyue Xi and Oliver Ratmann 
output: github_document
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r, include=FALSE} 
library(knitr)
require(kableExtra)
```

```{r, include=FALSE, eval=FALSE, echo=FALSE}
require(rmarkdown)
setwd('~/phyloscanner/phyloflows/vignettes')
infile <- '07_age_analysis.Rmd'
rmarkdown::render(infile, output_format='pdf_document')
rmarkdown::render(infile, output_format='md_document')
```

This vignette provides an extension of the general method of **phyloflow**. The aim is to understand the transmission flows between one-year increment age groups. The differences between this example with the general pipeline of **phyloflow** is the correlation between flows. To tackle this problem, we impose a Gaussian process (GP) prior on transmission flows. 


# Dataset
**We start with simulating transmission counts** between seven age groups called "15-19","20-24","25-29","30-34","35-39","40-44","45-49". Note that in practice, it would be good to use this method 
to investigate transmission dynamics between one-year increment age group, as the squared exponential kernel is 
for the continuous input space. We first set up hyperparameters for GP, the baseline and sampling fractions.
```{r, include=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE, message=FALSE, warning=FALSE}
library(rstan)
library(data.table)
library(ggplot2)
library(viridis)
set.seed(42)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
alpha_true <- c(2.5)
rho_true <- c(12,9)
mu_true <- -1
gp_dim <- 2
xi <- c(0.35, 0.45, 0.5, 0.55, 0.5, 0.55, 0.4)
```

**Next, we calculate the sampling probabilities of transmission flows
within and between the two groups.**  

```{r, include=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE, message=FALSE, warning=FALSE}
dobs <- data.table(expand.grid(TR_TRM_CATEGORY = c("15-19","20-24","25-29","30-34","35-39","40-44","45-49"),
                               REC_TRM_CATEGORY = c("15-19","20-24","25-29","30-34","35-39","40-44","45-49")))

ds <- data.table(CATEGORY = c("15-19","20-24","25-29",
                              "30-34","35-39","40-44","45-49"),
                 P = xi,ID = 1:7)
setnames(ds,colnames(ds),paste0('TR_TRM_',colnames(ds)))
dobs <- merge(dobs,ds,by='TR_TRM_CATEGORY')
setnames(ds,colnames(ds),gsub('TR_','REC_',colnames(ds)))
dobs <- merge(dobs,ds,by='REC_TRM_CATEGORY')
setnames(ds,colnames(ds),gsub('REC_TRM_','',colnames(ds)))
dobs[,P:= TR_TRM_P * REC_TRM_P]
dobs[,TR_SMOOTH_CATEGORY:=as.numeric(substr(TR_TRM_CATEGORY,1,2))+2]
dobs[,REC_SMOOTH_CATEGORY:=as.numeric(substr(REC_TRM_CATEGORY,1,2))+2]
dobs[, TR_SAMPLING_CATEGORY:= TR_TRM_CATEGORY]
dobs[, REC_SAMPLING_CATEGORY:= REC_TRM_CATEGORY]
```

**Next, we simulate true transmission flows and observed transmission counts.**
```{r, include=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE, message=FALSE, warning=FALSE}
simu_pars <- list(	N=nrow(dobs), D=gp_dim, x=cbind(dobs$TR_SMOOTH_CATEGORY,dobs$REC_SMOOTH_CATEGORY),
                   alpha=alpha_true, rho=rho_true,
                   mu=mu_true,xi=dobs$P)
#	simulate data set	
simu_fit <- stan(	file="simu_poiss.stan", 
                  data=simu_pars, iter=1,
                  chains=1, seed=424838, algorithm="Fixed_param")

dobs$TRM_OBS <- extract(simu_fit)$y[1,]	
```

# Input data: observed transmission flows
Input data of the similar format of **phyloflow** are expected.
```{r, include=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE, message=FALSE, warning=FALSE}
dobs <- subset(dobs, select = c('TR_TRM_CATEGORY', 'REC_TRM_CATEGORY','TR_SAMPLING_CATEGORY',
                                'REC_SAMPLING_CATEGORY', 'TR_SMOOTH_CATEGORY','REC_SMOOTH_CATEGORY',
                                'TRM_OBS'))
head(dobs)
```
**`dobs` specifies observed counts of transmissions from a
transmitter age group to a recipient age group.** It must contain the following columns:
 
* *TR_TRM_CATEGORY* name of transmitter group.
* *REC_TRM_CATEGORY* name of recipient group.
* *TR_SMOOTH_CATEGORY* midpoint of transmitter age group.
* *REC_SMOOTH_CATEGORY* midpoint of recipient age group.
* *TRM_CAT_PAIR_ID* identifier of transmitter-recipient pair
* *TRM_OBS* observed transmission counts

Let us look at the data. The first row shows zero counts of transmission
flows from age group "15-19" to age group "15-19". We visualise our simulated input data in the heatmap : 
```{r data, fig.margin=TRUE}
ggplot(dobs, aes(TR_SMOOTH_CATEGORY, REC_SMOOTH_CATEGORY))+
  geom_tile(aes(fill = TRM_OBS)) +
  scale_fill_viridis() +
  scale_x_continuous(expand = c(0,0), limits = c(14.5,49.5))+
  scale_y_continuous(expand = c(0,0), limits = c(14.5,49.5))+
  theme_classic()+
  labs(x='transmitter age group \n', y='\n recipient age group',fill='transmission \n counts')

```

## Input data: sampling information
** `dobs` also must contain information about how each group was sampled.** 
This is stored in the following columns:

* *TR_SAMPLING_CATEGORY* sampling strata of transmitter group
* *REC_SAMPLING_CATEGORY* sampling strata of recipient group

**`dprior.fit` specifies the distribution of sampling probability in each sampling group.** 
The sampling probability is either approximated by beta-binomial model or GLM model (See 01 - Simulating data). and provided by samples. In the tutorial, we opted for a probabilistic programming language Stan, and it cannot take samples as input. Alternatively, it is possible to fit statistical distributions to samples and input distribution parameters. The information is stored in data *dprior.fit* in the following columns: 

* *SAMPLING_CATEGORY* name of sampling strata
* *ALPHA, BETA* shape parameters of the distribution of sampling probability.

Under beta-binomial model, the posterior distribution of the sampling probability is known analytically, i.e. beta. Let us look at the sampling information:


```{r, include=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE, message=FALSE, warning=FALSE}
ds$TRIAL <- c(4000, 3700, 3300, 2500, 1700, 1000, 500)
ds[,SUC := round(TRIAL * P)]
dprior.fit <- copy(ds)
dprior.fit[,ALPHA := SUC+1]
dprior.fit[,BETA := TRIAL-SUC+1]
dprior.fit <- subset(dprior.fit, select = c('CATEGORY','ALPHA','BETA'))
colnames(dprior.fit) <- c('SAMPLING_CATEGORY','ALPHA','BETA')
head(dprior.fit)
```



# Method
Again we use a Bayesian approach to estimate the proportion of
transmissions between the two population groups. Please see the problem setting in 
*phyloflows: Estimating transmission flows under heterogeneous sampling -- a first example*.
Unlike the simple example,
a probabilistic programming language Stan provides a flexible platform to impose
different kinds of priors.
Recall the posterior distribution of the parameters $(\lambda, s)$ is given by 
$$
\begin{aligned}
p(\lambda, s | n) & \propto p(n | \lambda, s) p(\lambda, s) \\
              & = \prod_{i=1,\cdots,7;j=1\cdots,7} Poisson(n_{ij};\lambda_{ij}*s_i*s_j) p(\lambda_{ij}) p(s_i) p(s_j).
\end{aligned}
$$
Then, we calculate the main quantity of interest, $\pi$, via
$$
\pi_{ij}= \lambda_{ij} / \sum_{k=1,\cdots,7;  l=1,\cdots,7} \lambda_{kl}.
$$ 
for $i=1,\cdots,7$ and
$j=1,\cdots,7$.

**For the prior distributions**, we specify for $p(\lambda_{ij})$, $i=1,2; j=1,2$ 
uninformative prior distributions. We use a Gamma distribution with parameters
$\alpha_i=0.8/7^2$ and $\beta=0.8/Z$ with
  $Z= \sum_{ij | n_{ij}>0} n_{ij}/(s_i*s_j) + \sum_{ij | n_{ij}>0}
(1-s_i*s_j)/(s_i*s_j)$. This choice implies for $\pi$ a Dirichlet prior distribution with parameters $\alpha_i$, which
  is considered to be an objective choice. For $p(s_i)$, we use a strongly informative
prior distribution, based on the available data as illustrated above.





```{r, include=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE, message=FALSE, warning=FALSE}
 tmp <- subset(ds,select = c('CATEGORY','ID'))
 setnames(tmp, colnames(tmp), paste0('TR_TRM_',colnames(tmp)))
 dobs <- merge(dobs,tmp,by='TR_TRM_CATEGORY')
 setnames(tmp, colnames(tmp), gsub('TR_TRM_','REC_TRM_',colnames(tmp)))
 dobs <- merge(dobs,tmp,by='REC_TRM_CATEGORY')
 setnames(tmp, colnames(tmp), gsub('REC_TRM_','',colnames(tmp)))
 
 
 data.gamma <- list(N=nrow(dobs),
                   Y=dobs$TRM_OBS,
                   N_xi = nrow(dprior.fit),
                   shape = cbind(dprior.fit$ALPHA,dprior.fit$BETA),
                   xi_id = cbind(dobs$TR_TRM_ID,dobs$REC_TRM_ID),
                   alpha = 0.8/nrow(dobs))
```

After preparing data, we could estimate flows under independent Gamma prior.

```{r, include=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE, message=FALSE, warning=FALSE}
  fit.gamma <- stan(file = 'gamma.stan',
              data = data.gamma,
              iter = 3000,  warmup = 500, chains=1, thin=1, seed = 42,
              algorithm = "NUTS", verbose = FALSE,
              control = list(adapt_delta = 0.8, max_treedepth=10))
```  


```{r, include=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE, message=FALSE, warning=FALSE}
  M <- 30
  D <- 2 
  indices <- matrix(NA, M^D, D)
  mm=0;
  for (m1 in 1:M){
    for (m2 in 1:M){
      mm = mm+1
      indices[mm,] = c(m1, m2)
    }
  }
  
 

  data.gp <- list( M= M, M_nD= M^D, 
                         L= c(3/2*max(dobs$TR_SMOOTH_CATEGORY),3/2*max(dobs$REC_SMOOTH_CATEGORY)), 
                         N = nrow(dobs),
                         x = cbind(dobs$TR_SMOOTH_CATEGORY,dobs$REC_SMOOTH_CATEGORY),
                         D = D,
                         y = dobs$TRM_OBS,
                         indices= indices,
                         N_xi = nrow(ds),
                         shape = cbind(dprior.fit$ALPHA,dprior.fit$BETA),
                         xi_id = cbind(dobs$TR_TRM_ID,dobs$REC_TRM_ID))
  
```
After preparing data, we could estimate flows under independent Gaussian process prior.

```{r, include=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE, message=FALSE, warning=FALSE}
 fit.gp <- stan(file = 'gp.stan',
            data = data.gp,
            iter = 3000,  warmup = 500, chains=1, thin=1, seed = 42,
            algorithm = "NUTS", verbose = FALSE,
            control = list(adapt_delta = 0.8, max_treedepth=10))

```
Finally, we checked the effective sample size and Rhat for the Gamma fit. 

```{r, include=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE, message=FALSE, warning=FALSE}
range(summary(fit.gamma)$summary[, "n_eff"])
range(summary(fit.gamma)$summary[, "Rhat"])
params_gamma <- extract(fit.gamma)
```

Finally, we checked the effective sample size and Rhat for the GP fit. 

```{r, include=TRUE, eval=TRUE, echo=TRUE, tidy=FALSE, message=FALSE, warning=FALSE}
range(summary(fit.gp)$summary[, "n_eff"])
range(summary(fit.gp)$summary[, "Rhat"])
params_gp <- extract(fit.gp)
```

The histograms of hyperparameters are plotted in order to compare with true hyperparameter values under GP prior.
```{r posterior, fig.margin=TRUE}
c_light <- c("#DCBCBC")
c_dark <- c("#8F2727")
c_dark_highlight <- c("#7C0000")
par(mfrow=c(2, 2))	
hist(params_gp$alpha, main="", xlab="alpha", col=c_dark, border=c_dark_highlight, yaxt='n')
abline(v=2.5, col=c_light, lty=1, lwd=3)
hist(params_gp$rho[,1], main="", xlab="rho1", col=c_dark, border=c_dark_highlight, yaxt='n')
abline(v=12, col=c_light, lty=1, lwd=3)
hist(params_gp$rho[,2], main="", xlab="rho2", col=c_dark, border=c_dark_highlight, yaxt='n')
abline(v=9, col=c_light, lty=1, lwd=3)
hist(params_gp$mu, main="", xlab="mu", col=c_dark, border=c_dark_highlight, yaxt='n')
abline(v=-1, col=c_light, lty=1, lwd=3)
```


