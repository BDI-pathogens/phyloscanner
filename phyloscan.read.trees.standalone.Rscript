args <- commandArgs()
if(!any(args=='--args'))
	args<- vector("numeric",0)
if(any(args=='--args'))
	args<- args[-(1:match("--args", args)) ]
#	default args
indir					<- NA
infile					<- NA
outdir					<- NA
outgroup				<- NA
select					<- ''
references.pattern		<- 'REF'
run.pattern				<- ''
rm.newick				<- 0
rm.fasta				<- 0
tree.pattern			<- 'newick$'
plot.trees.per.page		<- 10 
plot.w					<- 20
plot.h					<- 40

if(exists("args"))
{	
	tmp<- na.omit(sapply(args,function(arg)
					{	switch(substr(arg,2,7),
								infile= return(substr(arg,9,nchar(arg))),NA)	}))
	if(length(tmp)>0) infile<- tmp[1]		
	tmp<- na.omit(sapply(args,function(arg)
					{	switch(substr(arg,2,6),
								indir= return(substr(arg,8,nchar(arg))),NA)	}))
	if(length(tmp)>0) indir<- tmp[1]	
	tmp<- na.omit(sapply(args,function(arg)
					{	switch(substr(arg,2,7),
								outdir= return(substr(arg,9,nchar(arg))),NA)	}))
	if(length(tmp)>0) outdir<- tmp[1]
	tmp<- na.omit(sapply(args,function(arg)
					{	switch(substr(arg,2,7),
								select= return(substr(arg,9,nchar(arg))),NA)	}))
	if(length(tmp)>0) select<- tmp[1]
	tmp<- na.omit(sapply(args,function(arg)
					{	switch(substr(arg,2,9),
								outgroup= return(substr(arg,11,nchar(arg))),NA)	}))
	if(length(tmp)>0) outgroup<- tmp[1]		
	tmp<- na.omit(sapply(args,function(arg)
					{	switch(substr(arg,2,19),
								references.pattern= return(substr(arg,21,nchar(arg))),NA)	}))
	if(length(tmp)>0) references.pattern<- tmp[1]
	tmp<- na.omit(sapply(args,function(arg)
					{	switch(substr(arg,2,12),
								run.pattern= return(substr(arg,14,nchar(arg))),NA)	}))
	if(length(tmp)>0) run.pattern<- tmp[1]
	tmp<- na.omit(sapply(args,function(arg)
					{	switch(substr(arg,2,9),
								rm.fasta= return(as.numeric(substr(arg,11,nchar(arg)))),NA)	}))
	if(length(tmp)>0) rm.fasta<- tmp[1]
	tmp<- na.omit(sapply(args,function(arg)
					{	switch(substr(arg,2,10),
								rm.newick= return(as.numeric(substr(arg,12,nchar(arg)))),NA)	}))
	if(length(tmp)>0) rm.newick<- tmp[1]	
	tmp<- na.omit(sapply(args,function(arg)
					{	switch(substr(arg,2,13),
								tree.pattern= return(substr(arg,15,nchar(arg))),NA)	}))
	if(length(tmp)>0) tree.pattern<- tmp[1]
	tmp<- na.omit(sapply(args,function(arg)
					{	switch(substr(arg,2,20),
								plot.trees.per.page= return(as.numeric(substr(arg,22,nchar(arg)))),NA)	}))
	if(length(tmp)>0) plot.trees.per.page<- tmp[1]
	tmp<- na.omit(sapply(args,function(arg)
					{	switch(substr(arg,2,7),
								plot.w= return(as.numeric(substr(arg,9,nchar(arg)))),NA)	}))
	if(length(tmp)>0) plot.w<- tmp[1]
	tmp<- na.omit(sapply(args,function(arg)
					{	switch(substr(arg,2,7),
								plot.h= return(as.numeric(substr(arg,9,nchar(arg)))),NA)	}))
	if(length(tmp)>0) plot.h<- tmp[1]
}
if( is.na(indir) )
{
	cat('\nusage: Rscript phyloscan.read.trees.standalone.Rscript -indir=INDIR
					\t\t\t[-infile=INFILE]  [-outdir=OUTDIR] [-outgroup=OUTGROUP]
					\t\t\t[-select=SELECT] [-references.pattern=REFPATTERN] [-run.pattern=RUNPATTERN]
					\t\t\t[-tree.pattern=TREEPATTERN] [-rm.newick=RMNEWICK] [-rm.fasta=RMFASTA]
					\t\t\t[-plot.trees.per.page=TREESPERPAGE] [-plot.w=PLOTW] [-plot.h=PLOTH] 
					\nThis R script processes phylotype newick files for further analyses. Processing includes 
					\t\t\tthe following steps. Rooting. Ancestral state reconstruction with maximum parsimony. 
					\t\t\tSave trees as a named list of trees in R ape format, and basic file info in an R object 
					\t\t\tfile. Plot trees. The R object file contains the trees in "pty.ph" and the basic file 
					\t\t\tinfo in "ptyfiles". The output file names are derived from the input file names, and end 
					\t\t\twith ".rda" and ".pdf" respectively.
					\nR users can use the function "pty.evaluate.tree" directly.    
					\narguments:\n
					\t-indir=INDIR: Input directory with newick trees.
					\noptional arguments:\n
					\t-infile=INFILE: Deprecated.
					\t-outdir=OUTDIR: Output directory. By default set to INDIR.
					\t-outgroup=OUTGROUP: Regular expression that uniquely identifies the root name. 
					\t\t\tMust be specified if infile is ommitted.
					\t-tree.pattern=TREEPATTERN: File name extension that identifies the newick files. By default "newick$";
					\t\t\tDo not include the dot. 
					\t-references.pattern=REFPATTERN: Regular expression that identifies all reference 
					\t\t\tsequences. By default "REF".
					\t-run.pattern=RUNPATTERN: String that identifies files of separate phylotype runs. 
					\t\t\tThe string must be followed by a number. Output is produced for each run separately.
					\t\t\tThis option is useful to group output as desired. Without the SELECT option, all 
					\t\t\tgroups will be processed sequentially. By default ""; could e.g. be "^ptyr" to 
					\t\t\tgroup newick files starting with "ptyr1_" and "ptyr2_" into two separate runs 
					\t\t\t"1" and "2".
					\t-select=SELECT: Regular expression that selects a subset of newick files in the 
					\t\t\tinput directory. This is useful to avoid very large file sizes and memory consumption 
					\t\t\tof this Rscript. Also useful to parallelize this processing step. By default ""; 
					\t\t\tcould e.g. be "^ptyr22_".
					\t-rm.newick=RMNEWICK: 1 to delete all newick files in the input directory. 
					\t\t\tBy default 0.
					\t-rm.fasta=RMFASTA: 1 to delete all fasta files in the input directory. 
					\t\t\tBy default 0.
					\t-plot.trees.per.page=TREESPERPAGE: Number of trees to plot per page. If >1, the number
					\t\t\tmust be divisible by 2. By default "10".
					\t-plot.w=PLOTW: Width of the plot page in inches. By default "20".
					\t-plot.h=PLOTH: Height of the plot page in inches. By default "40".
					\ninstallation notes:\n
					\tThis script requires a number of packages, and "ggtree" can be tricky to install.
					\t\t\tI had the most luck with the latest "scales0.3.0" and "ggplot2.0.0" from CRAN;
					\t\t\tI then cloned "ggtree" from github, built from source with "R CMD build
					\t\t\t--no-build-vignettes", and then installed the package. The required packages are
					\t\t\tape, phytools, phangorn, reshape2, data.table, RColorBrewer, colorspace, grid,
					\t\t\tgridExtra, ggplot2, ggtree, zoo.
					')
	quit('no')
}
if( is.na(outdir) )
	outdir	<- indir
if(1)
{
	print(infile) 
	print(indir) 
	print(outdir) 
	print(select) 
	print(outgroup)
	print(references.pattern)
	print(run.pattern)
	print(rm.newick)
	print(rm.fasta)
	print(tree.pattern)
	print(plot.trees.per.page) 
	print(plot.w)
	print(plot.h)	
}
###############################################################################
#	standalone: load packages
###############################################################################
require(ape)
require(phytools)
require(phangorn)
require(reshape2)
require(data.table)
require(RColorBrewer)
require(colorspace)
require(grid)
require(gridExtra)
require(ggplot2)
require(ggtree)
require(zoo)
###############################################################################
#	standalone: define functions
###############################################################################
pty.evaluate.tree.root.nofill<- function(ptyfiles, pty.ph, pty.runs)
{
	pty.root	<- lapply(ptyfiles[, unique(PTY_RUN)], function(ptyr){	
				#print(ptyr)	
				#ptyr<- 15
				tmp					<- subset(ptyfiles, PTY_RUN==ptyr)[,FILE]
				phs					<- lapply(tmp, function(x) pty.ph[[x]])	
				names(phs)			<- tmp
				#	number of read counts per individual				
				phpd				<- do.call('rbind',lapply(seq_along(phs),function(i){
									#i			<- 1
									#print(i)		
									ph			<- phs[[i]]
									phb			<- data.table(IDX=seq_along(ph$tip.label), BAM=ph$tip.label, FILE_ID= gsub('_read.*','',ph$tip.label))
									phb[, COUNT:= as.numeric(gsub('count_','',regmatches(BAM, regexpr('count_[0-9]+',BAM))))]
									phb			<- merge(phb, subset(pty.runs[pty.runs$PTY_RUN==ptyr,],select=FILE_ID), by='FILE_ID', all=1)
									set(phb, phb[, which(is.na(COUNT))], 'COUNT', 0)
									phb			<- phb[, list(COUNT=sum(COUNT)), by='FILE_ID']
									phb[, FILE:= names(phs)[i]]
									phb					
								}))
				phpd				<- merge(phpd, subset(ptyfiles, PTY_RUN==ptyr, select=c(FILE, W_FROM)), by='FILE')
				setkey(phpd, W_FROM)
				outgroup.order		<- phpd[, list(COUNT=mean(COUNT)), by='FILE_ID']				
				outgroup.order		<- merge(outgroup.order, phpd[, list(PRESENT=length(which(COUNT>0))), by='FILE_ID'], by='FILE_ID')
				setkey(outgroup.order, COUNT)
				outgroup.order		<- subset(outgroup.order, PRESENT>0)
				#	ususally not all present throughout; pick in order
				ans					<- do.call('rbind',lapply(seq_along(phs),function(i){
									#i			<- 147
									#print(i)
									ph				<- phs[[i]]							
									phb				<- data.table( IDX=seq_along(ph$tip.label), BAM=ph$tip.label, FILE_ID= gsub('_read.*','',ph$tip.label))				
									phb				<- merge(phb, outgroup.order, by='FILE_ID')
									outgroup.ind	<- phb[which.min(COUNT), FILE_ID]							
									phgd			<- cophenetic.phylo(ph)
									tmp				<- subset(phb, FILE_ID==outgroup.ind)[, BAM]
									if(length(tmp)<nrow(phgd))
										phgd		<- phgd[ tmp, setdiff(rownames(phgd), tmp), drop=FALSE]
									outgroup.seq	<- rownames(phgd)[ which(min(phgd)==phgd, arr.ind=TRUE)[1,1] ]
									data.table(FILE=names(phs)[i], ROOT=outgroup.seq)					
								}))
				ans[, PTY_RUN:= ptyr]
				ans				
			})
	pty.root	<- do.call('rbind',pty.root)
	pty.root
}
pty.evaluate.tree.root.withfill<- function(ptyfiles, pty.ph, pty.runs)
{
	pty.root	<- lapply(ptyfiles[, unique(PTY_RUN)], function(ptyr){	
				#print(ptyr)	
				#ptyr<- 15
				tmp			<- subset(ptyfiles, PTY_RUN==ptyr)[,FILE]
				phs			<- lapply(tmp, function(x) pty.ph[[x]])	
				names(phs)	<- tmp
				#get patristic distances between target and fill
				#if no target, select target_ind with lowest taxon index (just makes an unambiguous selection when windows are considered one by one)
				phpd		<- do.call('rbind',lapply(seq_along(phs),function(i){
									#i			<- 1
									print(i)
									ph			<- phs[[i]]							
									phb			<- data.table(IDX=seq_along(ph$tip.label), BAM=ph$tip.label, FILE_ID= gsub('_read.*','',ph$tip.label))				
									phb			<- merge(phb, pty.runs[pty.runs$PTY_RUN==ptyr,], by='FILE_ID', all=1)
									phgd		<- cophenetic.phylo(ph)
									tmp			<- subset(phb, !FILL & !is.na(BAM))[, BAM]
									if(length(tmp)==0)
									{
										tmp		<- subset(phb, !is.na(BAM))[, FILE_ID[which.min(TX_IDX)]]
										tmp		<- subset(phb, !is.na(BAM) & FILE_ID==tmp)[, BAM]
									}								
									tmp			<- phgd[ tmp, setdiff(rownames(phgd), tmp), drop=FALSE]
									stopifnot(ncol(tmp)>0)								
									ans			<- as.data.table(melt(tmp, value.name='PATR'))
									setnames(ans, c('Var1','Var2'), c('TARGET','FILL'))
									ans[, FILE:= names(phs)[i]]	
									ans[, IDX:=i]							
									ans							
								}))
				#print(phpd[, unique(IDX)])				
				phpd[, FILL_IND:= gsub('_read.*','',FILL)]				
				#print(phpd)		
				#	try consider as root only individual present across all BAM files
				tmp		<- phpd[, list(FILL_IND_N=length(FILL)), by=c('FILL_IND','FILE')]
				tmp		<- dcast.data.table(tmp, FILE~FILL_IND, value.var='FILL_IND_N')
				tmp		<- apply(tmp[,-1, with=FALSE], 2, function(x) !any(is.na(x))	)
				tmp		<- data.table(FILL_IND=names(tmp)[tmp])
				if(nrow(tmp)==0)	# 	may be empty
				{
					print(PTY_RUN)
					stop()
				}				
				tmp		<- merge(phpd, tmp, by='FILL_IND')
				#	select individual with average largest distance
				tmp		<- tmp[, list(PATR= median(PATR)), by='FILL_IND']	
				root	<- tmp[which.max(PATR),][,FILL_IND]
				ans		<- subset(phpd, FILL_IND==root)[, list(ROOT=FILL[which.max(PATR)]), by=c('IDX','FILE')]
				tmp		<- ans[, list(CHECK= ROOT%in%phs[[IDX]]$tip.label) , by='IDX']
				stopifnot( tmp[, all(CHECK)] )		
				ans[, IDX:=NULL]
				ans[, PTY_RUN:= ptyr]
				ans
			})
	pty.root	<- do.call('rbind',pty.root)
	pty.root
}
pty.evaluate.tree.groupindividuals<- function(ph, phb)
{
	tmp				<- lapply( phb[, unique(FILE_ID)], function(x)	subset(phb, FILE_ID==x)[, BAM]	)
	names(tmp)		<- phb[, unique(FILE_ID)]
	ph				<- groupOTU(ph, tmp, group='INDIVIDUAL')		
	z	<- merge(data.table(FROM=ph$edge[,1],IDX=ph$edge[,2]), phb, by='IDX', all=1)
	z[, GROUP:= attr(ph,'INDIVIDUAL')[1:nrow(ph$edge)]]
	z	<- unique(subset(z, !is.na(FILE_ID), select=c(FILE_ID, GROUP)))
	attr(ph,'INDIVIDUAL')	<- factor(attr(ph,'INDIVIDUAL'), levels=c(0,z[,as.character(GROUP)]), labels=c('not characterized',z[,FILE_ID]))
	ph
}
pty.evaluate.tree<- function(indir, pty.runs=NULL, outdir=indir, select='', outgroup=NA, references.pattern='REF', run.pattern='ptyr', tree.pattern='newick$', rm.newick=FALSE, rm.fasta=FALSE, plot.trees.per.page=10, plot.w=20, plot.h=40)
{	
	if(0)
	{
		indir		<- "~/Dropbox (Infectious Disease)/2015_PANGEA_DualPairsFromFastQIVA/coinf_ptoutput_150121"
		indir		<- "~/Dropbox (Infectious Disease)/2015_PANGEA_DualPairsFromFastQIVA/coinf_ptoutput_150201"
		outdir		<- indir
		pty.infile	<- "~/Dropbox (Infectious Disease)/2015_PANGEA_DualPairsFromFastQIVA/data/PANGEA_HIV_n5003_Imperial_v160110_ZA_examlbs500_coinfrunsinput.rda"
		select		<- '^ptyr22_In'
		outgroup	<- NA
		outgroup	<- "CPX_AF460972"
	}
	stopifnot(!is.null(pty.runs) || (is.null(pty.runs) & !is.na(outgroup)))
	#
	#	collect ML tree files
	#
	ptyfiles		<- data.table(FILE=list.files(indir, tree.pattern))
	if(nchar(run.pattern))
		ptyfiles[, PTY_RUN:= as.numeric(gsub(run.pattern,'',sapply(strsplit(FILE,'_'),'[[',1)))]
	if(!nchar(run.pattern))
		ptyfiles[, PTY_RUN:=1L]
	ptyfiles[, W_FROM:= as.numeric(gsub('InWindow_','',regmatches(FILE,regexpr('InWindow_[0-9]+',FILE))))] 
	ptyfiles[, W_TO:= as.numeric(gsub('to_','',regmatches(FILE,regexpr('to_[0-9]+',FILE))))]
	ptyfiles		<- subset(ptyfiles, grepl(select,FILE))
	setkey(ptyfiles, PTY_RUN, W_FROM)
	cat('\nfound tree files, n=',nrow(ptyfiles))
	#ptyfiles		<- subset(ptyfiles, W_FROM<9000)
	#
	#ptyfiles[, table(PTY_RUN)]
	#	raw trees w/o any attributes
	pty.ph		<- lapply( seq_len(nrow(ptyfiles)), function(i)
			{				
				ph			<- read.tree(file.path(indir,ptyfiles[i, FILE]))
				#	node labels
				if(is.null(ph$node.label))
					ph$node.label	<- rep('0',Nnode(ph))
				tmp				<- ph$node.label
				tmp[which(tmp=='Root'|tmp=='')]	<- '0'
				ph$node.label	<- as.numeric(tmp)
				ph
			})
	names(pty.ph)<- ptyfiles[, FILE]
	#
	ptyfiles[, IND_N:= sapply(seq_along(pty.ph), function(i)  length(unique(gsub('_read.*','',pty.ph[[i]]$tip.label)))		)]
	#	rm trees with just one individual if no outgroup specified	
	if(is.na(outgroup) && pty.runs[, any(FILL==1)])
	{
		cat('\nignoring trees with only one individual (only when no root specified)', subset(ptyfiles, IND_N==1)[, paste(unique(FILE),collapse=', ')])
		ptyfiles		<- subset(ptyfiles, IND_N>1)
		pty.ph			<- lapply( ptyfiles[, FILE], function(x)	pty.ph[[x]]		)
		names(pty.ph)	<- ptyfiles[, FILE]			
	}	
	ptyfiles[, IDX:=seq_len(nrow(ptyfiles))]
	#
	#	GET ROOTS
	#	
	#	root specified; check if in tree
	if(!is.na(outgroup))
	{
		cat('\nroot and evaluate trees')
		pty.root	<- ptyfiles[, {
					#FILE<- 'ptyr22_InWindow_241_to_300_dophy_examl.newick'
					ans		<- NA_character_
					tmp		<- which(grepl(outgroup,pty.ph[[FILE]]$tip.label))
					if(length(tmp)==0)
						cat('\ncannot find root', outgroup,'in tree',FILE,', ignoring file')
					if(length(tmp)==1)
						ans	<- pty.ph[[FILE]]$tip.label[tmp]
					if(length(tmp)>1)
						cat('\nfound >1 roots', outgroup,'in tree',FILE,', ignoring file')
					list(ROOT=ans)
				}, by= c('FILE','PTY_RUN')]
		pty.root	<- subset(pty.root, !is.na(ROOT))	
		ptyfiles	<- merge(ptyfiles,pty.root, by=c('FILE','PTY_RUN'))
	}
	#	root not specified; determine root for each run: find taxon with largest distance from BAM of selected individuals (these have FILL==0)
	if(is.na(outgroup) && pty.runs[, any(FILL==1)])
	{
		cat('\ndetermine root among fillers')
		pty.root	<- pty.evaluate.tree.root.withfill(ptyfiles, pty.ph, pty.runs)
		ptyfiles	<- merge(ptyfiles,pty.root, by=c('FILE','PTY_RUN'))
	}
	#	root not specified; determine root for each run: 
	if(is.na(outgroup) && pty.runs[, all(FILL==0)])
	{
		cat('\ndetermine root among all individuals')
		pty.root	<- pty.evaluate.tree.root.nofill(ptyfiles, pty.ph, pty.runs)
		ptyfiles	<- merge(ptyfiles,pty.root, by=c('FILE','PTY_RUN'))
	}	
	#
	#	trees: root, ladderize, group
	#
	#pty.ph.cp			<- copy(pty.ph)	
	#	pty.ph	<- copy(pty.ph.cp)
	cat('\nroot, ladderize, group trees')
	for(i in seq_along(pty.ph))
	{
		cat('\nprocess tree ',names(pty.ph)[i])
		#print(i)
		#i<- 44
		#i<- 5
		root			<- subset(ptyfiles, FILE==names(pty.ph)[i])[, ROOT]
		ph				<- pty.ph[[i]]
		tmp										<- which(ph$tip.label==root)
		ph										<- reroot(ph, tmp, ph$edge.length[which(ph$edge[,2]==tmp)])
		ph$node.label[ph$node.label=='Root']	<- 0
		ph$node.label							<- as.numeric(ph$node.label)			
		ph				<- ladderize(ph)
		phb				<- data.table(IDX=seq_along(ph$tip.label), BAM=ph$tip.label, FILE_ID= gsub('_read.*','',ph$tip.label), REF=grepl(references.pattern,ph$tip.label))
		set(phb, phb[, which(REF)],'FILE_ID','REFERENCE')
		tmp				<- phb[, which(!grepl('_read_[0-9]+_count_[0-9]+',BAM))]
		#	homogenize taxon labels
		if(length(tmp))
		{
			stopifnot( !nrow(subset(phb[tmp, ],!REF))	)	#incorrect taxon label
			set(phb, tmp, 'BAM', phb[tmp, paste(BAM,'_read_1_count_0',sep='')])
			setkey(phb, IDX)
			ph$tip.label	<- phb[,BAM]			
		}
		#	group edges by individual
		ph				<- pty.evaluate.tree.groupindividuals(ph, phb)
		#	group edges by FILL
		#tmp			<- as.numeric(gsub('ptyr','',regmatches(names(pty.ph)[i], regexpr('ptyr[0-9]+',names(pty.ph)[i]))))
		#phb			<- merge(phb, subset(pty.runs, PTY_RUN==tmp), by='FILE_ID')
		#ph				<- pty.evaluate.tree.groupindividuals(ph, phb)	
		pty.ph[[i]]		<- ph
	}		
	#
	#	save trees
	#	
	tmp		<- ptyfiles[1, gsub(paste('.',tree.pattern,sep=''),'_preprtr.rda',gsub('_dophy','',gsub('\\.InWindow_[0-9]+_to_[0-9]+|_InWindow_[0-9]+_to_[0-9]+','',FILE)))]
	cat('\nsave trees to file ',tmp)
	save(pty.ph, ptyfiles, file=file.path(outdir,tmp))
	#
	#	remove newick / fasta files
	#
	if(rm.newick)
	{
		invisible( ptyfiles[, list(SUCCESS=file.remove(file.path(indir,FILE))), by='FILE'] )
		invisible( ptyfiles[, list(SUCCESS=file.remove(file.path(indir,gsub('newick','txt',FILE)))), by='FILE'] )
	}
	if(rm.fasta)
	{
		invisible( ptyfiles[, list(SUCCESS=file.remove(file.path(indir,gsub('_examl\\.newick','\\.fasta',FILE)))), by='FILE'] )
	}
	#
	#	plot full trees
	#
	#	need node heights to determine x-axis for plotting
	tmp					<- ptyfiles[,{										
				ph		<- pty.ph[[FILE]]
				tmp		<- node.depth.edgelength(ph)[1:Ntip(ph)]
				list(BAM=ph$tip.label, HEIGHT=tmp)
			}, by='FILE']	
	ptyfiles				<- merge(ptyfiles, tmp[, list(HMX= max(HEIGHT)), by='FILE'], by='FILE')
	setkey(ptyfiles, PTY_RUN, W_FROM)	
	#	plot by run.pattern
	#ptyfiles			<- subset(ptyfiles, PTY_RUN==1)
	for(ptyr in ptyfiles[, unique(PTY_RUN)])
	{
		#ptyr<- 22
		cat('\nplot trees with run.pattern',ptyr,'\n\n')
		tmp			<- subset(ptyfiles, PTY_RUN==ptyr)
		#	setup title
		tmp[, TITLE:=paste('run',PTY_RUN,', window [',W_FROM,',',W_TO,']',sep='')]
		setkey(tmp, W_FROM)
		phs			<- lapply(tmp[, FILE], function(x) pty.ph[[x]])
		names(phs)	<- tmp[, TITLE] 
		#	setup colours	
		tmp2		<- setdiff(sort(unique(unlist(lapply(seq_along(phs), function(i)	levels(attr(phs[[i]],'INDIVIDUAL'))	)))),c('not characterized'))
		if(!'REFERENCE'%in%tmp2)
		{
			col			<- c('black',rainbow_hcl(length(tmp2), start = 270, end = -30, c=100, l=50))
			names(col)	<- c('not characterized',tmp2)						
		}
		if('REFERENCE'%in%tmp2)
		{
			tmp2		<- setdiff(tmp2,'REFERENCE')
			col			<- c('grey50','black',rainbow_hcl(length(tmp2), start = 270, end = -30, c=100, l=50))
			names(col)	<- c('not characterized','REFERENCE',tmp2)						
		}		
		#	setup ggtrees
		phps		<- lapply(seq_along(phs), function(i){
					cat('\nsetup tree ',names(phs)[i])
					max.node.height	<- tmp[i,][, HMX]
					ph				<- phs[[i]]					
					df			<- data.table(	BAM=ph$tip.label, IDX=seq_along(ph$tip.label), 
							COUNT= as.numeric(gsub('count_','',regmatches(ph$tip.label, regexpr('count_[0-9]+',ph$tip.label)))), 
							CLU=grepl('_clu',ph$tip.label), 
							FILE_ID= gsub('_read.*|_clu.*','',ph$tip.label))
					set(df, df[, which(grepl(references.pattern,FILE_ID))],'FILE_ID','REFERENCE')
					p			<- ggtree(ph, aes(color=INDIVIDUAL)) %<+% df +
							geom_nodepoint(size=ph$node.label/100*3) +
							geom_tippoint(aes(size=COUNT, shape=CLU)) +
							#geom_point2(aes(subset=(node==42)), size=5, shape=23, fill='#068C00') +
							#geom_point2(data=df, aes(subset=(node==IDX)), size=5, shape=23, fill=df[,COL]) +
							#geom_text(aes(label=label), size=1.5,  hjust=-.1) +
							geom_tiplab(size=1.2,  hjust=-.1) +
							scale_color_manual(values=col, guide=FALSE) +
							scale_shape_manual(values=c(20,18), guide=FALSE) +
							scale_size_area(guide=FALSE) +							
							theme_tree2() +
							theme(legend.position="bottom") + ggplot2::xlim(0, max.node.height*1.3) +
							labs(x='subst/site', title=names(phs)[i])
					p
				})	
		names(phps)	<- names(phs)
		file	<- file.path( indir, tmp[1,gsub(paste('.',tree.pattern,sep=''),'.pdf',gsub('_dophy','',gsub('.InWindow_[0-9]+_to_[0-9]+|_InWindow_[0-9]+_to_[0-9]+','',FILE)))] )
		cat('\nplot trees to file ',file)		
		tmp			<- seq_len(ceiling(length(phps)/plot.trees.per.page))
		#	single-page plot
		if(plot.trees.per.page==1)
		{
			pdf(file=file, w=plot.w, h=plot.h)		#for win=60
			for(i in tmp)
				print(phps[[i]])
			dev.off()
		}
		#	multi-page plot
		if(plot.trees.per.page>1)
		{
			stopifnot( plot.trees.per.page%%2==0 )			
			pdf(file=file, w=plot.w, h=plot.h)		#for win=60
			for(i in tmp)
			{		
				grid.newpage()
				pushViewport(viewport(layout=grid.layout(2, plot.trees.per.page/2)))
				z	<- intersect(seq.int((i-1)*plot.trees.per.page+1, i*plot.trees.per.page), seq_len(length(phps)))
				for(j in z)
					print(phps[[j]], vp = viewport(layout.pos.row=(ceiling(j/(plot.trees.per.page/2))-1)%%2+1, layout.pos.col=(j-1)%%(plot.trees.per.page/2)+1))				
			}
			dev.off()
		}					
	}
}		
###############################################################################
#	run script
###############################################################################
pty.runs	<- NULL
if(!is.na(infile))
{
	load( infile )		# loads pty.runs, only used to define outgroup if not specified
}
pty.evaluate.tree(	indir, pty.runs=pty.runs, outdir=outdir, select=select, outgroup=outgroup, 
		references.pattern=references.pattern, run.pattern=run.pattern, tree.pattern=tree.pattern, 
		rm.newick=rm.newick, rm.fasta=rm.fasta,
		plot.trees.per.page=plot.trees.per.page, plot.w=plot.w, plot.h=plot.h)
#
#	plot additional smaller trees, not do for now
#
#tmp		<- data.table(FILE=list.files(outdir, pattern='examl.rda$'))
#tmp		<- subset(tmp, grepl(select,FILE))
#tmp		<- file.path(outdir, tmp[1,FILE])
#load( tmp )			# loads ptyfiles, pty.ph
#pty.evaluate.tree.collapse(pty.runs, ptyfiles, pty.ph, outdir, thresh.brl=8e-6)
