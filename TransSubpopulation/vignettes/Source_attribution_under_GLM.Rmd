---
title: "Source attribution when adjustment for sampling differences uses individual covariates"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

[In the previous tutorial](Source_attribution_under_SARWS_assumption.html), we inferred transmission flows between subpopulations when sampling differences are corrected by using the number of eligible and sampled individuals. **In this tutorial, we will give an example to infer the transmission between community 1 and 2 while sampling differences are corrected by using individual covariates through generalised linear model.** We will:

1. Introduce data for using this source attribution method.
2. Generate samples from the prior distribution of sampling probability predicted by generalised linear model.
3. Estimate transmission flows while accounting for sampling differences.

## Simulating data
**We first simulate data for sampling.** 'dp' is a data table containing the number of individuals who are eligible (**TRIAL**) and sampled (**SUC**) in each subpopulation (**CATEGORY**). Assume there are two subpopulations defined by communities where the number of infected and ART-naive individuals are 2000 and 2500 in community 1 and 2 repectively. 

We then generate individual covariates including gender and age. Assume 70% infected individuals are women in location 1, among which 25%, 60% and 15% are aged 15-24, 25-34 and 35+; among men in location 1, 20%, 50% and 30% are aged 15-24, 25-34 and 35+. Assume 60% infected individuals are women in location 2, among which 25%, 50% and 25% are aged 15-24, 25-34 and 35+; among men in location 2, 20%, 40% and 40% are aged 15-24, 25-34 and 35+. 

```{r, include=FALSE} 
library(knitr)
```


```{r, results="markup"} 
library(data.table)
library(gtools)
library(TransSubpopulation)
setwd("~/phyloscanner/TransSubpopulation/vignettes/")

set.seed(42)
num.inf.1<-2000
num.inf.2<-2500
ds<-data.table(COMM_NUM_B=c(rep(1,num.inf.1),rep(2,num.inf.2)),INF=rep(1,num.inf.1+num.inf.2))
num.f.1<-round(num.inf.1*0.7)
num.m.1<-num.inf.1-round(num.inf.1*0.7)
num.f.2<-round(num.inf.2*0.6)
num.m.2<-num.inf.2-round(num.inf.2*0.6)

ds$SEX<-c(rep('F',num.f.1),
          rep('M',num.m.1),
          rep('F',num.f.2),
          rep('M',num.m.2))

ds$AGE_AT_MID_C<-c(rep('15-24',round(num.f.1*0.25)),
                   rep('25-34',round(num.f.1*0.6)),
                   rep('35+',num.f.1-round(num.f.1*0.25)-round(num.f.1*0.6)),
                   rep('15-24',round(num.m.1*0.2)),
                   rep('25-34',round(num.m.1*0.5)),
                   rep('35+',num.m.1-round(num.m.1*0.2)-round(num.m.1*0.5)),
                   rep('15-24',round(num.f.2*0.25)),
                   rep('25-34',round(num.f.2*0.5)),
                   rep('35+',num.f.2-round(num.f.2*0.25)-round(num.f.2*0.5)),
                   rep('15-24',round(num.m.2*0.2)),
                   rep('25-34',round(num.m.2*0.4)),
                   rep('35+',num.m.2-round(num.m.2*0.2)-round(num.m.2*0.4))
)

```

We can aggregate the number of infected people by age, gender and communities. Assume regression coefficients are as follows:

1. the overall intercept: 0.4.
2. deviations from the overall intercepts for location 1 and 2: 0.5 and -0.5.
3. regression coefficients for the variables 'being male', 'being young' and 'being mid-age' are 0.4, 0.3 and 0.2.

```{r} 
ds		<- ds[, list(TRIAL=length(INF)),by=c('AGE_AT_MID_C','SEX','COMM_NUM_B')]
comm<-c(0.5,-0.5)
a<-0.4
male<-0.4
young<-0.3
midage<-0.2
```

Ages and genders are binarised to create regression covariates, through which we could predict the sampling probability of the subpopulation $a$, $\xi_a$, and the number of sequenced individuals in $a$, $X_a^s \sim \mbox{Binomial}(X_a^i,\xi_a)$.

```{r} 
ds[, AGE1:= as.integer(AGE_AT_MID_C=='15-24')]
ds[, AGE2:= as.integer(AGE_AT_MID_C=='25-34')]
ds[, MALE:= as.integer(SEX=='M')]

ds[,LOGIT_P_SEQ:=a + comm[COMM_NUM_B] + male*MALE + young*AGE1 + midage*AGE2]
ds[,P_SEQ:=exp(LOGIT_P_SEQ)/(1+exp(LOGIT_P_SEQ))]
ds[,SUC:=rbinom(nrow(ds),TRIAL,P_SEQ)]

ds[,CATEGORY:=paste0(COMM_NUM_B,':',SEX,':',AGE_AT_MID_C)]
ds[,COMM_NUM_B:=as.integer(COMM_NUM_B)]
```

**We then simulate transmissions between subpopulations.** 'dobs' a data table containing all the combinations of subpopulations transmitting (**TR_TRM_CATEGORY**) and receiving (**REC_TRM_CATEGORY**) the disease. Heterosexual transmission pairs are kept only.

```{r} 
dobs<-as.data.table(expand.grid(TR_TRM_CATEGORY=ds$CATEGORY,REC_TRM_CATEGORY=ds$CATEGORY))
dobs[, c("TR_COMM_NUM_B","TR_SEX", "TR_AGE_AT_MID_C") := tstrsplit(TR_TRM_CATEGORY, ":", fixed=TRUE)]
dobs[, c("REC_COMM_NUM_B","REC_SEX", "REC_AGE_AT_MID_C") := tstrsplit(REC_TRM_CATEGORY, ":", fixed=TRUE)]
dobs<-dobs[TR_SEX!=REC_SEX,]
dobs[, TRM_CAT_PAIR_ID:= seq_len(nrow(dobs))]
```

Transmission probabilities are assigned to each transmission pair. Assume transmissions are less likely to occur between different locations, to elder individuals in male-female transmissions and to younger individuals in female-male transmissions. Transmission probabilities are modelled by Dirichlet distribution where hyperparameters are set to be around 1 for these less probable pairs and around 2 for the rest of pairs. We set the transmission probabilities to be the mean of Dirichlet distribution.

```{r} 
lbd   <- rnorm(nrow(dobs),2,0.2)
tmp   <- dobs[TR_COMM_NUM_B!=REC_COMM_NUM_B,TRM_CAT_PAIR_ID]
lbd[tmp]  <- rnorm(length(tmp),1,0.2)
tmp   <- dobs[TR_COMM_NUM_B==REC_COMM_NUM_B & TR_SEX=='M' &
                ( (TR_AGE_AT_MID_C=='15-24' & REC_AGE_AT_MID_C=='25-34')|
                    (TR_AGE_AT_MID_C=='25-34' & REC_AGE_AT_MID_C=='35+')|
                    (TR_AGE_AT_MID_C=='15-24' & REC_AGE_AT_MID_C=='35+') ),TRM_CAT_PAIR_ID]
lbd[tmp]  <- rnorm(length(tmp),1,0.2)
tmp   <- dobs[TR_COMM_NUM_B==REC_COMM_NUM_B & TR_SEX=='F' &
                ( (TR_AGE_AT_MID_C=='25-34' & REC_AGE_AT_MID_C=='15-24')|
                    (TR_AGE_AT_MID_C=='35+' & REC_AGE_AT_MID_C=='15-24')|
                    (TR_AGE_AT_MID_C=='35+' & REC_AGE_AT_MID_C=='25-34') ),TRM_CAT_PAIR_ID]
lbd[tmp]  <- rnorm(length(tmp),1,0.2)
TRUE_PI<-lbd/sum(lbd)
dobs[,TRUE_PI:=as.vector(TRUE_PI)]

tmp<-dobs[,sum(TRUE_PI),by=c('TR_COMM_NUM_B','REC_COMM_NUM_B')]
setkey(tmp,TR_COMM_NUM_B,REC_COMM_NUM_B)
TRUE_PI_V<-tmp$V1
```


The probability of sampling a transmission event from one subpopulation to another is calculated by the product of sampling probability of transmitters and recipients. 
```{r} 
tmp<-subset(ds,select=c('CATEGORY','P_SEQ'))
setnames(tmp,colnames(tmp),paste0('TR_TRM_',colnames(tmp)))
dobs<-merge(dobs,tmp,by='TR_TRM_CATEGORY')
setnames(tmp,colnames(tmp),gsub('TR_','REC_',colnames(tmp)))
dobs<-merge(dobs,tmp,by='REC_TRM_CATEGORY')
dobs[, S:= TR_TRM_P_SEQ * REC_TRM_P_SEQ]
```

Assume the observed transmission count is 300, and the observed transmissions between subpopulations could be simulated as follows:
  
  1. generate the true transmission count $Z$ by a Poisson distribution with the parameter 300/ the mean sampling rates of pairs.
  2. generate the true transmissions between groups by $z \sim \mbox{Multinomial} (Z,\pi)$.
  3. generate the observed transmissions from $a$ to $b$ by $n_{ab} \sim \mbox{Binomial} (z_{ab},\vartheta_{ab}), \forall a,b$ where $\vartheta_{ab}$ is the probability of sampling a transmission event from $a$ to $b$.
  
```{r} 
N<-rpois(1,300/mean(dobs$S))
z<-rmultinom(1,size=N,prob=TRUE_PI)
n<-matrix(NA_integer_,ncol=1,nrow=length(TRUE_PI))
for (i in 1:length(TRUE_PI)){
  n[i]<-rbinom(1,size=z[i],dobs$S[i])
}
```

Then, we record the observed count in 'dobs':

```{r,results='hide', message=FALSE, warning=FALSE} 
dobs[, TRM_OBS:= n]
dobs<-dobs[TRM_OBS!=0,]
dobs[, TRM_CAT_PAIR_ID:= seq_len(nrow(dobs))]

# remove irrelevant terms
set(ds,NULL,c('P_SEQ','LOGIT_P_SEQ'),NULL)
set(dobs,NULL,c('TR_TRM_P_SEQ','REC_TRM_P_SEQ','S','TRUE_PI',
                'TR_COMM_NUM_B', 'TR_SEX', 'TR_AGE_AT_MID_C', 'REC_COMM_NUM_B', 'REC_SEX',
                'REC_AGE_AT_MID_C'),NULL)
```

No immigration is considered in this example. Transmission categories are, thus, consistent with sampling categories; that is, if an individual is sampled in a subpopulation and he/she transmits HIV, the transmission originates from this subpopulation.

```{r} 
dobs[,TR_SAMPLING_CATEGORY:=TR_TRM_CATEGORY]
dobs[,REC_SAMPLING_CATEGORY:=REC_TRM_CATEGORY]
```

Here, we present the form of **dobs**.
```{r,echo=FALSE} 
library(knitr)
kable(dobs,caption = 'Data on transmission events (dobs)')
```

In practice, **dobs** could be aggregated from transmission events inferred from **phyloscanner**.

## Generating samples from the prior of the sampling rates

Assume an individual in community $a$ is sampled at random with probability $\xi_a$. If we know the number of infected $X_a^i$ and sequenced individuals $X_a^s$ in all the subpopulations, and individual covariates, we could infer the posterial distribution $\xi_a$ through stan.

```{r,results='hide', message=FALSE, warning=FALSE} 
library(rstan)
library(bayesplot)
infile.sequencing.stan.model<-'glm_age3sex2comm2bin.stan'
#	run STAN 
	tmp			<- as.list(subset(ds,select=c('COMM_NUM_B','TRIAL','SUC','MALE','AGE1','AGE2')))
	tmp$N		<- nrow(ds)
	tmp$N_COMM	<- length(unique(ds$COMM_NUM_B))
	fit.par 	<- stan(	file = infile.sequencing.stan.model, 
						data = tmp, 
						iter = 10e3,
						warmup = 5e2,
						cores = 1,
						chains = 1,
						init = list(list(a=0, comm=rep(0,2), sig_comm=1, male=0, age1=0, age2=0)))
```

The convergence of the stan code can be examined by effective sample size and trace plots.
	
```{r,results='hide', message=FALSE, warning=FALSE} 
	fit.pars	<- c('a','comm','sig_comm','male','age1','age2')
	any(rhat(fit.par, pars=fit.pars)>1.02)
	any(neff_ratio(fit.par, pars=fit.pars) * 9.5e3 < 500)
	po              <- as.matrix(fit.par) 
	po              <- po[, colnames(po)[!grepl('p_suc|lp__',colnames(po))]]	
	p   <- mcmc_trace(po, pars=colnames(po), facet_args = list(ncol = 1)) 
	pdf(file='190327_participation_model_marginaltraces.pdf', w=7, h=100)
	p
	dev.off()
```

We can extract samples from the posterior distribution of $\xi_a$ and use them as samples from the informative prior distribution. These samples are recorded in **dprior**.
```{r,results='hide', message=FALSE, warning=FALSE} 
	nprior  <- 1000
	set.seed(42)
	dprior   <- data.table(CATEGORY=unique(c(dobs$TR_TRM_CATEGORY,dobs$REC_TRM_CATEGORY)))
	dprior[, COMM_NUM_B:= dprior[, gsub('^(.+)\\:(.)\\:(.+)$','\\1',CATEGORY)]]
	dprior[, SEX:= dprior[,gsub('^(.+)\\:(.)\\:(.+)','\\2',CATEGORY)]]
	dprior[, AGE_AT_MID_C:= dprior[, gsub('^(.+)\\:(.)\\:(.+)$','\\3',CATEGORY)]]
	dprior[, AGE1:= as.integer(AGE_AT_MID_C=='15-24')]
	dprior[, AGE2:= as.integer(AGE_AT_MID_C=='25-34')]
	dprior[, MALE:= as.integer(SEX=='M')]
	dprior[, COMM_NUM_B:=as.integer(COMM_NUM_B)]
	
	fit.e		<- extract(fit.par)
	tmp			<- sample(length(fit.e$a), nprior)
	dprior			<- dprior[,	
			{
				z<- with(fit.e, a + comm[,COMM_NUM_B] + male * MALE + 
								age1 * AGE1 + age2 * AGE2)
				list(SAMPLE=1:nprior, ETA=as.numeric(z[tmp]))
			},	
			by=c('CATEGORY')]
	dprior[, P:= exp(ETA)/(1+exp(ETA))]
	
	require(bde)
	tmp	<- dprior[, {
				bdest<- bde(P, dataPointsCache=sort(P), b=0.001, estimator='betakernel', lower.limit=0, upper.limit=1,
				            options=list(modified=FALSE, normalization='densitywise', mbc='none', c=0.5))
				list(SAMPLE=SAMPLE, LP=log(density(bdest, P)))
			}, by='CATEGORY']
	dprior	<- merge(dprior, tmp, by=c('CATEGORY','SAMPLE'))
	set(dprior, NULL, c('ETA'), NULL)	
	setnames(dprior, 'CATEGORY', 'SAMPLING_CATEGORY')
```

Here, we present the form of **dobs**.
```{r,echo=FALSE} 
kable(head(dprior),caption = 'the first 6 rows of dprior')
```

## Source attribution while adjusting for sampling bias  
After preparing **dobs** and **dprior**, we can infer the transmissions between subpopulations while adjusting for sampling bias through the function **source.attribution.mcmc**.

```{r} 
mcmc.file<-'S1MCMC_GLM.rda'
```

```{r, results='hide', message=FALSE, warning=FALSE,eval=FALSE} 
control=list(seed=42, mcmc.n=nrow(dobs)*1e5, verbose=0, outfile=mcmc.file)
source.attribution.mcmc(dobs, dprior, control)
```

```{r,include = FALSE}
load(mcmc.file)
```

The source attribution methods takes `r round(mc$time,2)` minutes. The convergence and mixing of the algorithm could be examined through **source.attribution.mcmc.diagnostics**.
```{r, results='hide', message=FALSE, warning=FALSE} 
control		<- list(	burnin.p=0.05, 
                  regex_pars='*', 
							    credibility.interval=0.95, 
							    pdf.plot.all.parameters=FALSE, 
							    pdf.plot.n.worst.case.parameters=10, 
							    pdf.height.per.par=1.2, 
							outfile.base=gsub('\\.rda','',mcmc.file))
source.attribution.mcmc.diagnostics(mcmc.file, control=control)
```

Aggregating outputs from MCMC gives transmissions between community 1 and 2.

```{r,results='hide', message=FALSE, warning=FALSE}
#	aggregate MCMC output to 1<->2
  aggregate.file	<- gsub('\\.rda','_aggregatedCommunity.csv',mcmc.file)
  daggregateTo	<- subset(dobs, select=c(TRM_CAT_PAIR_ID, TR_TRM_CATEGORY, REC_TRM_CATEGORY))
  daggregateTo[, TR_TARGETCAT:=dobs[, gsub('^(.+)\\:(.)\\:(.+)$','\\1',TR_TRM_CATEGORY)]]
  daggregateTo[, REC_TARGETCAT:=dobs[, gsub('^(.+)\\:(.)\\:(.+)$','\\1',REC_TRM_CATEGORY)]]
    
  set(daggregateTo, NULL, c('TR_TRM_CATEGORY','REC_TRM_CATEGORY'), NULL)	
  control			<- list(	burnin.p=0.05, 
                     thin=NA_integer_, 
                     regex_pars='*', 
                     outfile=aggregate.file)
  source.attribution.mcmc.aggregateToTarget(mcmc.file, daggregateTo, control=control)
```

Outputs are summarised by median and 95\% credible interval, which is illustrated together with the true transmission probabilities as follows:
```{r,results='hide', message=FALSE, warning=FALSE}
  #	calculate flows sources WAIFM flow_ratio overall		
  control			<- list(	quantiles= c('CL'=0.025,'IL'=0.25,'M'=0.5,'IU'=0.75,'CU'=0.975),
                     flowratios= list(),
                     outfile=gsub('\\.csv','_flowsetc.csv',aggregate.file))
  source.attribution.aggmcmc.getKeyQuantities(aggregate.file, control)
```

```{r}
da<-as.data.table(read.csv('S1MCMC_GLM_aggregatedCommunity_flowsetc.csv'))
da<-da[STAT=='flows',]
da<-subset(da,select=c('TR_TARGETCAT','REC_TARGETCAT','LABEL2'))
da[,TRUE_PI:=TRUE_PI_V]
```

```{r,echo=FALSE} 
kable(da,caption = 'comparison of actual and inferred transmission flows')
```
