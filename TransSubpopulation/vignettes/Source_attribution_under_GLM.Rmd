---
title: "Source attribution while sampling are structured under the GLM assumption"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Simulating sampling data

We start by simulating data required for this task. 'dg' is a data table containing the number of individuals who are eligible (**TRIAL**) and sampled (**SUC**) and covarites for each subpopulation (**CATEGORY**). Assume there are two locations where the numbers of infected individuals are 120 and 80. 

Now we generate covariates for individuals (gender and age). Assume 70% infected individuals are women in location 1, among which 25%, 60% and 15% are aged 15-24, 25-34 and 35+; among men in location 1, 20%, 50% and 30% are aged 15-24, 25-34 and 35+. Assume 60% infected individuals are women in location 1, among which 25%, 50% and 25% are aged 15-24, 25-34 and 35+; among men in location 1, 20%, 40% and 40% are aged 15-24, 25-34 and 35+. 
```{r, include=FALSE} 
library(knitr)
```

```{r, results="markup"} 
library(data.table)
library(gtools)
library(TransSubpopulation)
set.seed(123)
dg<-data.table(COMM_NUM_B=c(rep(1,120),rep(2,80)),INF=rep(1,200))
num.f.1<-round(120*0.7)
num.m.1<-120-round(120*0.7)
num.f.2<-round(80*0.6)
num.m.2<-80-round(80*0.6)

dg$SEX<-c(rep('F',num.f.1),
          rep('M',num.m.1),
          rep('F',num.f.2),
          rep('M',num.m.2))
dg$AGE_AT_MID_C<-c(rep('15-24',round(num.f.1*0.25)),
                   rep('25-34',round(num.f.1*0.6)),
                   rep('35+',num.f.1-round(num.f.1*0.25)-round(num.f.1*0.6)),
                   rep('15-24',round(num.m.1*0.2)),
                   rep('25-34',round(num.m.1*0.5)),
                   rep('35+',num.m.1-round(num.m.1*0.2)-round(num.m.1*0.5)),
                   rep('15-24',round(num.f.2*0.25)),
                   rep('25-34',round(num.f.2*0.5)),
                   rep('35+',num.f.2-round(num.f.2*0.25)-round(num.f.2*0.5)),
                   rep('15-24',round(num.m.2*0.2)),
                   rep('25-34',round(num.m.2*0.4)),
                   rep('35+',num.m.2-round(num.m.2*0.2)-round(num.m.2*0.4))
                   )

```
Based on these covariates, we compute the number of infected individuals $X_a^i$ in each subpopulation stratified by age, gender and locations. Assume regression coefficients as follows:

1. intercept: 0.4
2. varying intercepts for location 1 and 2: 0.5,-0.5
3. regression coefficients for the variables 'being male', 'being young' and 'being mid-age' are 0.4, 0.3 and 0.2. 
```{r} 
dg		<- dg[, list(TRIAL=length(INF)),by=c('AGE_AT_MID_C','SEX','COMM_NUM_B')]
comm<-c(0.5,-0.5)
a<-0.4
male<-0.4
young<-0.3
midage<-0.2
```

Age and genders are then binarised for regression covariates which are then used to evaluate the sampling rate of group a $\mbox{logit}(\xi_a)$. Based on $\xi_a$, the number of individuals being sequenced $X_a^s$ is generated by a Binomial distribution $\mbox{Binomial}(X_a^i,\xi_a)$.
```{r} 
dg[, AGE1:= as.integer(AGE_AT_MID_C=='15-24')]
dg[, AGE2:= as.integer(AGE_AT_MID_C=='25-34')]
dg[, MALE:= as.integer(SEX=='M')]

dg[,LOGIT_P_SEQ:=a + comm[COMM_NUM_B] + male*MALE + young*AGE1 + midage*AGE2]
dg[,P_SEQ:=exp(LOGIT_P_SEQ)/(1+exp(LOGIT_P_SEQ))]
dg[,SUC:=rbinom(nrow(dg),TRIAL,P_SEQ)]

dg[,CATEGORY:=paste0(COMM_NUM_B,':',SEX,':',AGE_AT_MID_C)]
dg[,COMM_NUM_B:=as.integer(COMM_NUM_B)]
```

## Simulating transmission data

'dc' is created by all ordered combination of subpopulations in 'dg' and only heterosexual transmission pairs are kept.
```{r} 
dc<-as.data.table(expand.grid(TR_CATEGORY=dg$CATEGORY,REC_CATEGORY=dg$CATEGORY))
dc[,COUNT_ID:=1:nrow(dc)]
dc[, c("TR_COMM_NUM_B","TR_SEX", "TR_AGE_AT_MID_C") := tstrsplit(TR_CATEGORY, ":", fixed=TRUE)]
dc[, c("REC_COMM_NUM_B","REC_SEX", "REC_AGE_AT_MID_C") := tstrsplit(REC_CATEGORY, ":", fixed=TRUE)]

dc<-dc[TR_SEX!=REC_SEX,]
```

Assume transmissions are less likely to occur between different locations, to elder individuals in male-female transmissions and to younger individuals in female-male transmissions. Dirichlet hyperparameters are set to be around 1 for these less probable pairs and around 2 for the rest of pairs. The probabilities of transmissions between subpopulations are then given by the mean of the Dirichlet distribution.

```{r} 
lbd<-matrix(NA_real_,nrow = 1, ncol = nrow(dc))
for (i in 1:nrow(dc)){
  if (dc$TR_COMM_NUM_B[i]==dc$REC_COMM_NUM_B[i]){
    if ( (dc$TR_AGE_AT_MID_C[i]=='15-24' & dc$REC_AGE_AT_MID_C[i]=='25-34') |
         (dc$TR_AGE_AT_MID_C[i]=='15-24' & dc$REC_AGE_AT_MID_C[i]=='35+') |
         (dc$TR_AGE_AT_MID_C[i]=='25-34' & dc$REC_AGE_AT_MID_C[i]=='35+')){
      if (dc$TR_SEX[i]=='M'){
        lbd[i]<-rnorm(1,1,0.2)
      }else{
        lbd[i]<-rnorm(1,2,0.2)
      }
    }else if ( (dc$REC_AGE_AT_MID_C[i]=='15-24' & dc$TR_AGE_AT_MID_C[i]=='25-34') |
               (dc$REC_AGE_AT_MID_C[i]=='15-24' & dc$TR_AGE_AT_MID_C[i]=='35+') |
               (dc$REC_AGE_AT_MID_C[i]=='25-34' & dc$TR_AGE_AT_MID_C[i]=='35+')){
      if (dc$TR_SEX[i]=='M'){
        lbd[i]<-rnorm(1,2,0.2)
      }else{
        lbd[i]<-rnorm(1,1,0.2)
      }
    }else if(dc$TR_AGE_AT_MID_C[i]==dc$REC_AGE_AT_MID_C[i]){
      lbd[i]<-rnorm(1,2,0.2)
    }
  }else{
    lbd[i]<-rnorm(1,1,0.2)
  }
}
TRUE_PI<-lbd/sum(lbd)
dc[,TRUE_PI:=as.vector(TRUE_PI)]
```

Here presented the assymmetric transmission matrix
```{r,echo=FALSE}
trasition_mtx<-matrix(0,nrow=length(dg$CATEGORY),ncol=length(dg$CATEGORY))
for (i in 1:nrow(dc)){
  row.id<-which(dg$CATEGORY==dc$TR_CATEGORY[i])
  col.id<-which(dg$CATEGORY==dc$REC_CATEGORY[i])
  trasition_mtx[row.id,col.id]<-round(dc$TRUE_PI[i],4)
}
rownames(trasition_mtx)<-dg$CATEGORY
colnames(trasition_mtx)<-dg$CATEGORY
kable(as.data.frame.matrix(trasition_mtx))
```


Predicted sequencing rates for each subpopulation in 'dg' are used to evaluate the probability of a transmission between two subpopulations being observed.
```{r} 
tmp<-subset(dg,select=c('CATEGORY','P_SEQ'))
setnames(tmp,colnames(tmp),paste0('TR_',colnames(tmp)))
dc<-merge(dc,tmp,by='TR_CATEGORY')
setnames(tmp,colnames(tmp),gsub('TR_','REC_',colnames(tmp)))
dc<-merge(dc,tmp,by='REC_CATEGORY')
dc[,S:=TR_P_SEQ*REC_P_SEQ]
```

Assume the observed transmission count is 20, and the observed transmissions between subpopulations could be simulated as follows:

1. generate the true transmission count $Z \sim \mbox{Poisson} (20/S)$
2. generate the true transmissions between groups $z \sim \mbox{Multinomial} (Z,\pi)$
3. generate the observed transmissions between groups $n_{ab} \sim \mbox{Binomial} (z_{ab},\vartheta_{ab}), \forall a,b$

```{r} 
N<-rpois(1,20/mean(dc$S))
z<-rmultinom(1,size=N,prob=TRUE_PI)
n<-matrix(NA_integer_,ncol=1,nrow=length(TRUE_PI))
for (i in 1:length(TRUE_PI)){
  n[i]<-rbinom(1,size=z[i],dc$S[i])
}
```

Observed transmissions between groups are recorded from the simulation and id numbers are set for the stratified transmissions.

```{r} 
dc$OBS<-n
dc.obs.zero<-which(dc$OBS==0)
dc<-dc[which(dc$OBS!=0),]
dc$COUNT_ID<-1:nrow(dc)

# remove irrelevant terms
dg$P_SEQ<-NULL
dg$LOGIT_P_SEQ<-NULL
dc$TR_P_SEQ<-NULL
dc$REC_P_SEQ<-NULL
dc$S<-NULL
dc$TRUE_PI<-NULL
dc[,TR_COMM_NUM_B:=as.integer(TR_COMM_NUM_B)]
dc[,REC_COMM_NUM_B:=as.integer(REC_COMM_NUM_B)]
```

'df.sampling' is a list of data table composed of 'dg'.
```{r} 
df.sampling<-list()
df.sampling[[1]]<-dg
```

Here we present the form of the inputs of prior generator under GLM, i.e. **df.sampling** and **dc**.
```{r,echo=FALSE} 
kable(df.sampling[[1]],caption = 'df.sampling[[1]]')
kable(dc,caption = 'dc')
```

## Implementing the bias-adjusted algorithm

We now draw samples from the prior distribution using GLM. The function will depend on covariates and the function 'samples.from.GLM.prior' from this package is an example. Running the following lines gives you information required for MCMC algorithm, i.e. S.DTL.prior and TR.OBS and save data under your working directory.

```{r,eval=FALSE}
samples.from.GLM.prior(df.sampling=df.sampling,dc=dc,iteration=3e6,sample.method='empirical',glm.model=c('binomial'),seed=123)
```

After loading the samples from the prior distribution, we can use the following algorithm to estimate the proportion of transmissions between subpopulations when correcting for sampling differences.

```{r,include = FALSE}
load('InputsMCMC_GLM3e+06.rda')
```

```{r,eval=FALSE}
mcmc.core.inference(s.dtl.prior=S.DTL.prior,tr.obs=TR.OBS,seed=123)
```


The estimated proportions of transmissions between subpopulations are summerised as follows.
```{r,include = FALSE}
load('core_inference_SNPIZ_mcmcEachCount_GLM.rda')
```


```{r}
# runtime of the algorithm
print(time)

dc.obs.nonzero<-setdiff(1:length(TRUE_PI),dc.obs.zero)
PI.summary<-data.table(PI_MEDIAN=rep(0,length(TRUE_PI)),
                       PI_LOWER=rep(0,length(TRUE_PI)),
                       PI_UPPER=rep(0,length(TRUE_PI)),
                       PI_TRUE=as.vector(TRUE_PI),
                       ID=1:length(TRUE_PI))
PI.summary$PI_MEDIAN[dc.obs.nonzero]<-apply(mc$pars$PI,2,median)
PI.summary$PI_LOWER[dc.obs.nonzero]<-apply(mc$pars$PI,2,function(x){quantile(x,0.025)})
PI.summary$PI_UPPER[dc.obs.nonzero]<-apply(mc$pars$PI,2,function(x){quantile(x,0.975)})
```


```{r,echo=FALSE}
kable(PI.summary,caption = 'summary of PI')
```


```{r}
# runtime of the algorithm
print(time)

dc.obs.nonzero<-setdiff(1:length(TRUE_PI),dc.obs.zero)
PI.summary<-data.table(PI_MEDIAN=rep(0,length(TRUE_PI)),
                       PI_LOWER=rep(0,length(TRUE_PI)),
                       PI_UPPER=rep(0,length(TRUE_PI)),
                       PI_TRUE=TRUE_PI,
                       ID=1:length(TRUE_PI))
PI.summary$PI_MEDIAN[dc.obs.nonzero]<-apply(mc$pars$PI,2,median)
PI.summary$PI_LOWER[dc.obs.nonzero]<-apply(mc$pars$PI,2,function(x){quantile(x,0.025)})
PI.summary$PI_UPPER[dc.obs.nonzero]<-apply(mc$pars$PI,2,function(x){quantile(x,0.975)})
```
If you want to visualise MCMC convergence diagnostics, you may use the function 'mcmc.core.inference.diagnostics' and all the results are saved in your computer.
```{r,results='markup',warning=FALSE}
mcmc.core.inference.diagnostics(mc,2e3)
```

