args <- commandArgs()
if(!any(args=='--args'))
	args<- vector("numeric",0)
if(any(args=='--args'))
	args<- args[-(1:match("--args", args)) ]
#	default args
indir					<- NA
outdir					<- NA
select					<- ''
references.pattern		<- 'REF'
run.pattern				<- 'ptyr'
plot.max.clade			<- 0

if(exists("args"))
{	
	tmp<- na.omit(sapply(args,function(arg)
					{	switch(substr(arg,2,6),
								indir= return(substr(arg,8,nchar(arg))),NA)	}))
	if(length(tmp)>0) indir<- tmp[1]	
	tmp<- na.omit(sapply(args,function(arg)
					{	switch(substr(arg,2,7),
								outdir= return(substr(arg,9,nchar(arg))),NA)	}))
	if(length(tmp)>0) outdir<- tmp[1]
	tmp<- na.omit(sapply(args,function(arg)
					{	switch(substr(arg,2,7),
								select= return(substr(arg,9,nchar(arg))),NA)	}))
	if(length(tmp)>0) select<- tmp[1]
	tmp<- na.omit(sapply(args,function(arg)
					{	switch(substr(arg,2,15),
								plot.max.clade= return(as.numeric(substr(arg,17,nchar(arg)))),NA)	}))
	if(length(tmp)>0) plot.max.clade<- tmp[1]		
	tmp<- na.omit(sapply(args,function(arg)
					{	switch(substr(arg,2,19),
								references.pattern= return(substr(arg,21,nchar(arg))),NA)	}))
	if(length(tmp)>0) references.pattern<- tmp[1]
	tmp<- na.omit(sapply(args,function(arg)
					{	switch(substr(arg,2,12),
								run.pattern= return(substr(arg,14,nchar(arg))),NA)	}))
	if(length(tmp)>0) run.pattern<- tmp[1]			
}
if( is.na(indir) )
{
	cat('\nusage: Rscript phyloscan.scan.superinfections.Rscript -indir=INDIR
					\t\t\t[-outdir=OUTDIR] [-select=SELECT] [-references.pattern=REFPATTERN]
					\t\t\t[-run.pattern=RUNPATTERN] [-plot.max.clade=PMAXCLADE]
					\nThis R script scans short read trees for phylogenetic evidence of super-infections. 
					\t\t\tShort read trees must have been pre-processed with "phyloscan.evaluate.examl.Rscript"
					\t\t\tand stored in an R object file ending in "_preprtr.rda". The script reads these files from
					\t\t\tdirectory INDIR and calculates several tree statistics. Tree statistics are stored in
					\t\t\tcorresponding R object files ending in "_stat.rda", as well as several ".csv" files. 
					\t\t\tIf PMAXCLADE is set to a value >1, scan statistics for each individual are plotted to a 
					\t\t\tcorresponding pdf file.
					\nR users can use the functions "pty.stat.superinfections.XXX" and "pty.stat.superinfections.XXX.plot" directly.    
					\narguments:\n
					\t-indir=INDIR: Input directory with pre-processed short read trees in files ending with "_examl.rda".
					\noptional arguments:\n
					\t-outdir=OUTDIR: Output directory. By default set to INDIR.
					\t-references.pattern=REFPATTERN: Regular expression that identifies all reference 
					\t\t\tsequences. By default "REF".
					\t-run.pattern=RUNPATTERN: String that identifies files of separate phylotype runs. 
					\t\t\tThe string must be followed by a number. Output is produced for each run separately.
					\t\t\tThis option is useful to group output as desired. Without the SELECT option, all 
					\t\t\tgroups will be processed sequentially. By default ""; could e.g. be "^ptyr" to 
					\t\t\tgroup newick files starting with "ptyr1_" and "ptyr2_" into two separate runs 
					\t\t\t"1" and "2".
					\t-select=SELECT: Regular expression that selects a subset of newick files in the 
					\t\t\tinput directory. This is useful to avoid very large file sizes and memory consumption 
					\t\t\tof this Rscript. Also useful to parallelize this processing step. By default ""; 
					\t\t\tcould e.g. be "^ptyr22_".
					\t-plot.max.clade=PMAXCLADE: Plot scan statistics for the largest PMAXCLADE monophyletic 
					\t\t\tclades of every individual in each window. By default 0.
					')
	quit('no')
}
if( is.na(outdir) )
	outdir	<- indir
if(1)
{ 
	print(indir) 
	print(outdir) 
	print(select) 
	print(references.pattern)
	print(run.pattern)
	print(plot.max.clade)
}
###############################################################################
#	standalone: load packages
###############################################################################
require(ape)
require(phytools)
require(phangorn)
require(reshape2)
require(data.table)
require(RColorBrewer)
require(colorspace)
require(grid)
require(gridExtra)
require(ggplot2)
require(ggtree)
require(zoo)
###############################################################################
#	standalone: define functions
###############################################################################
#
#	This function calculates in the sub-clade of tree 'ph' that is defined by 'mrca'
#	- the number of tips (UREAD_N),
#	- the sum of reads (READ_N),
#	- the average node depth of all tips to the mrca of the sub-clade (AVG_ROOT2TIP)
#	Optionally, calculations can be restricted to taxa with taxon names that contain the string 'select'.
#
#	The function returns a list.
#
#	I use the select argument to count taxa/tips only from a specific individual, e.g. the selected
#	taxon names all contain the string 'Individual1' or 'BEEHIVE123' or 'R22_TASP2353'; whatever is 
#	specified in 'select'.
pty.stat.avgnodedepth.and.counts<- function(ph, mrca, select=NA)
{
	if(mrca<=Ntip(ph))
	{
		phb		<- data.table(	BAM=ph$tip.label[mrca],
				IND=gsub('_read.*','',ph$tip.label[mrca]),
				COUNT=as.numeric(gsub('count_','',regmatches(ph$tip.label[mrca], regexpr('count_[0-9]+',ph$tip.label[mrca])))),											
				DEPTH=0	)
	}
	if(mrca>Ntip(ph))
	{
		ph		<- extract.clade(ph,mrca)
		phb		<- data.table(	BAM=ph$tip.label,
				IND=gsub('_read.*','',ph$tip.label),
				COUNT= as.numeric(gsub('count_','',regmatches(ph$tip.label, regexpr('count_[0-9]+',ph$tip.label))))	)
		phb[, DEPTH:=node.depth.edgelength(ph)[seq_len(Ntip(ph))]]
	}		
	if(!is.na(select))
		phb		<- subset(phb, grepl(select,IND))
	list(AVG_ROOT2TIP=phb[, sum(DEPTH*COUNT) / sum(COUNT)], READ_N=phb[, sum(COUNT)], UREAD_N=phb[, length(COUNT)])	
}
#	This function calculates all monophyletic sub-clades of each individual in the phylogeny 'ph'
#	
#	The function returns a data.table with columns
#	- IND: individual name
#	- MRCA: node ID in 'ph' of the mrca of all taxa of the individual IND
#	- CLADE: node ID in 'ph' of the mrca of one monophyletic clade of the individual IND
pty.stat.monophyletic.clades<- function(ph)
{
	phb			<- data.table(IDX=seq_along(ph$tip.label), BAM=ph$tip.label, IND= gsub('_read.*','',ph$tip.label), REF=grepl(references.pattern,ph$tip.label))
	set(phb, phb[, which(REF)],'IND','REFERENCE')
	#	for each patient define mrca (MRCA)
	#	for each patient, 
	#		determine MRCA (mrca)
	#		calculate number of other individuals in clade below MRCA (diff)	
	z			<- phb[, {
				#print(GROUP)
				mrca	<- IDX		
				diff	<- 0L
				if(length(IDX)>1)
				{
					mrca	<- as.integer(getMRCA(ph, IDX))
					tmp		<- extract.clade(ph, mrca, root.edge=1)
					#print(tmp)
					diff	<- length(setdiff(gsub('_read.*','',tmp$tip.label), IND))								
				}												
				list(MRCA=mrca, DIFF_IND=diff)							
			}, by=c('IND')]	
	z			<- subset(z, IND!='REFERENCE')
	#	for all patients that are not monophyletic, there could be several clades
	#		trace back all ancestors between tips of other individuals and MRCA
	#		for each such tip, construct the unique path to MRCA that is not on a previous path
	#		find change points on these unique paths below which the subtree contains reads from the current patient
	#		the idea is that all monophyletic clades of this patient must break off from one of these paths	
	tmp			<- subset(z, DIFF_IND>0, c(IND, MRCA))
	if(!nrow(tmp))
		z[, CLADE:=NA_integer_]
	if(nrow(tmp))
	{
		#	find all tips that belong to another patient than the current individual
		tmp			<- tmp[, {
					if(MRCA<=Ntip(ph))
						tmp	<- ph$tip.label[MRCA]
					if(MRCA>Ntip(ph))
						tmp	<- extract.clade(ph,MRCA)$tip.label
					list(MRCA=MRCA, MRCA_IND=IND, BAM=tmp)	
				}, by='IND']
		tmp[, IND:=NULL]
		zz			<- merge(tmp, subset(phb, select=c(BAM, IND, IDX)), by='BAM')
		zz			<- subset(zz, MRCA_IND!=IND)
		#	determine change points
		zz			<- zz[, {
					#IDX<- c(980,910,912,950); MRCA<- 1580; IND<- 'R1_RES669_S20_L001'; MRCA_IND<- 'R1_RES827_S23_L001'					
					#	determine paths to MRCA from each tip
					anc.group		<- Ancestors(ph, IDX)	
					if(!is.list(anc.group))
						anc.group	<- list(anc.group)
					anc.group	<- lapply(seq_along(anc.group), function(i)  anc.group[[i]][ seq_len(which(anc.group[[i]]==MRCA[1])-1)] )							
					#	determine unique paths until we hit a path that is already visited
					anc.join	<- lapply(seq_along(anc.group), function(i){	unique(unlist(lapply(seq_len(i), function(j) anc.group[[j]])))	})
					anc.join	<- c(NA,anc.join)
					anc.group	<- lapply(seq_along(anc.group), function(i)	setdiff(anc.group[[i]],anc.join[[i]])	)
					#	check which clades defined by the mrcas on the ancestor path contain at least one read from MRCA_IND
					tmp			<- lapply(seq_along(anc.group), function(i) sapply(anc.group[[i]], function(j)	any(grepl(MRCA_IND, extract.clade(ph,j)$tip.label))		)	)				
					#	determine lowest node (counting from tips) which contains at least one read from MRCA_IND
					tmp			<- lapply(seq_along(tmp), function(i){
								ans		<- NA_integer_	
								tmp2	<- integer(0)
								if(length(tmp[[i]]))
									tmp2<- which(tmp[[i]]) 
								if(length(tmp2))
									ans	<- as.integer(anc.group[[i]][tmp2[1]])										
								ans
							})				
					list(IDX=IDX, CHANGE_NODE=unlist(tmp))
				},by=c('IND','MRCA','MRCA_IND')]
		zz			<- subset(zz, !is.na(CHANGE_NODE))
		#	each ancestor before a change node could have as one of its children a monophyletic clade from this patient
		setkey(zz, MRCA_IND, CHANGE_NODE)
		zz	<- unique(zz)
		zz	<- zz[, {
					#CHANGE_NODE<- 2053; MRCA<- 1580; MRCA_IND<- 'R1_RES827_S23_L001'
					#MRCA<- 1212; MRCA_IND<- 'R1_RES669_S20_L001'; CHANGE_NODE<- 1218
					#	the first two potentially monophyletic clades are the children of the CHANGE_NODE
					tmp			<- Children(ph, CHANGE_NODE)					
					#	define path from change node to just before mrca 					
					path		<- c(CHANGE_NODE, setdiff( Ancestors(ph,CHANGE_NODE), c(MRCA,Ancestors(ph,MRCA)) ))
					#	monophyletic clades could break off the path ending at MRCA
					#	the mrca's of these clades are the siblings of the path constructed above 
					pot.clade	<- c(tmp, unlist(Siblings(ph, path)))
					#	check if potential clades are monophyletic
					tmp			<- sapply(pot.clade, function(x){
								if(x<=Ntip(ph))
									ans	<- grepl(MRCA_IND, ph$tip.label[x])
								if(x>Ntip(ph))
									ans	<- all(grepl(MRCA_IND, extract.clade(ph,x)$tip.label))
								ans
							})	
					#	return monophyletic clades
					list(CLADE=as.integer(pot.clade[tmp]))
				}, by=c('MRCA_IND','CHANGE_NODE')]
		zz[, CHANGE_NODE:=NULL]
		setnames(zz,'MRCA_IND','IND')
		#	merge all monophyletic clades
		z	<- merge(z, unique(zz), all=1, by='IND', allow.cartesian=TRUE)
	}	
	tmp	<- z[, which(DIFF_IND==0)]
	set(z, tmp, 'CLADE', z[tmp,MRCA])
	#	double check CLADEs (the MONOPH_PA condition is key)
	if(nrow(z))
	{
		tmp	<- z[,{
					if(CLADE<=Ntip(ph))
						tmp	<- grepl(IND, ph$tip.label[CLADE])
					if(CLADE>Ntip(ph))
						tmp	<- all(grepl(IND, extract.clade(ph,CLADE)$tip.label))
					list(MONOPH=tmp, MONOPH_PA=all(grepl(IND, extract.clade(ph,Ancestors(ph, CLADE, type="parent"))$tip.label)))
				}, by=c('IND','CLADE')]
		stopifnot(tmp[, all(MONOPH)], tmp[, !any(MONOPH_PA)])	
	}	
	z	
}
#
#	This function calculates the scan statistics used in Christophe's last ColourTree.R file
#	The changes are:
#	- are faster and less mem intensive clade finding algorithm
#	- this algorithm returns only the node id that defines monophyletic clades
#	- this allows us to calculate all kinds of statistics afterwards
pty.stat.superinfections.160208<- function(pty.ph, ptyfiles, references.pattern='REF')
{	
	#	@CF: with data.table, the df[, {}, by=BY] syntax specifies the columns BY to loop over
	#	@CF: the return variables of a data.table block {} are either a named list, or another data.table
	#	@CF: one difference to data.frame is that the column names are available as variable names inside the block {}
	
	#	For each phylotype run (PTY_RUN), each patient (IND), each window (W_FROM, W_TO):
	#	- find the root node (CLADE) defining all monophyletic clades		
	stat.clades	<- ptyfiles[, {
				#FILE		<- subset(ptyfiles, W_FROM==661)[,FILE]
				#FILE<- 'ptyr22_InWindow_481_to_540_dophy_examl.newick'
				cat('\n',FILE)
				ph			<- pty.ph[[FILE]]
				pty.stat.monophyletic.clades(ph)							
			}, by=c('PTY_RUN','W_FROM','W_TO','FILE')]
	gc()	
	#	For each monophyletic clade:
	#	- calculate the mean node root-to-tip within clade, weighted by read count
	#	- calculate the number of reads
	#	- calculate the number of unique reads
	tmp			<- stat.clades[, {
				#tmp<- subset(stat.clades, W_FROM==661); FILE<- tmp[,FILE]
				#FILE<- 'ptyr22_InWindow_661_to_720_dophy_examl.newick'; CLADE<- 2066
				#cat('\n',FILE)
				ph			<- pty.ph[[FILE]]
				tmp			<- pty.stat.avgnodedepth.and.counts(ph, CLADE, select=NA)	
				names(tmp)	<- paste(names(tmp),'_CLADE',sep='')				
				tmp
			}, by=c('PTY_RUN','W_FROM','W_TO','FILE','CLADE')]
	stat.clades	<- merge(stat.clades, tmp, by=c('PTY_RUN','W_FROM','W_TO','FILE','CLADE'))
	gc()	
	#	For each phylotype run (PTY_RUN), each patient (IND), each window (W_FROM, W_TO):
	#	- calculate the average root to tip distance, weighted by read count
	#	  this requires the MRCA which can be expensive but has already been computed
	#	- calculate the total number of reads 
	#	- calculate the number of unique reads
	setkey(stat.clades, PTY_RUN, W_FROM, W_TO, FILE, IND)
	tmp			<- subset(unique(stat.clades), select=c(PTY_RUN, W_FROM, W_TO, FILE, IND, MRCA))
	stat.ind	<- tmp[,{
				ph			<- pty.ph[[FILE]]
				pty.stat.avgnodedepth.and.counts(ph, MRCA, select=IND)				
			}, by=c('PTY_RUN','W_FROM','W_TO','FILE','IND')]
	set(stat.ind, NULL, 'UREAD_N', stat.ind[, as.numeric(UREAD_N)])
	#	For each phylotype run (PTY_RUN), each patient (IND), each window (W_FROM, W_TO):
	#	- calculate number of clades
	tmp			<- stat.clades[, list(CLADE_N=as.numeric(length(CLADE))), by=c('PTY_RUN','W_FROM','W_TO','FILE','IND')]	
	stat.ind	<- merge(stat.ind, tmp, by=c('PTY_RUN','W_FROM','W_TO','FILE','IND'))
	#	For each monophyletic clade:
	#	- calculate the proportion of reads in the clade
	#	- calculate clade order by proportion
	stat.clades	<- merge(stat.clades, subset(stat.ind, select=c(PTY_RUN, W_FROM, W_TO, FILE, IND, READ_N)), by=c('PTY_RUN','W_FROM','W_TO','FILE','IND'))	
	stat.clades[, READ_P_CLADE:= READ_N_CLADE/READ_N]
	stat.clades[, READ_N:= NULL]
	stat.clades	<- stat.clades[ order(PTY_RUN, W_FROM, W_TO, FILE, IND, -READ_P_CLADE), ]	
	tmp			<- stat.clades[, list(ORDER_CLADE= seq_along(CLADE), CLADE=CLADE), by=c('PTY_RUN','W_FROM','W_TO','FILE','IND')]
	stat.clades	<- merge(stat.clades, tmp, by=c('PTY_RUN','W_FROM','W_TO','FILE','IND','CLADE'))
	#
	#	check that all reads are in one clade
	#
	tmp			<- stat.clades[, list(READ_N_CHECK=sum(READ_N_CLADE)), by=c('PTY_RUN','W_FROM','W_TO','FILE','IND')]	
	tmp			<- merge(tmp, subset(stat.ind, select=c(PTY_RUN, W_FROM, W_TO, FILE, IND, READ_N)), by=c('PTY_RUN','W_FROM','W_TO','FILE','IND'))
	stopifnot( !nrow(subset(tmp, READ_N_CHECK<READ_N))	)
	list(stat.clades=stat.clades, stat.ind=stat.ind)
}
pty.stat.superinfections.160208.plot<- function(stat.clades, stat.ind, outfile, plot.max.clade=5)
{			
	#
	#	print by patient
	#
	
	#	@CF: To get a sub-plot for each statistic using 'facet_grid', I melt the data.table
	#	@CF: the 'set' command looks a bit weird, but is great because it avoids creating new R objects via '<-'
	
	#	melt the statistics on individuals
	stat.plot	<- melt(stat.ind, measure.vars=c('READ_N','UREAD_N','CLADE_N','AVG_ROOT2TIP'), id.vars=c('PTY_RUN','W_FROM','W_TO','FILE','IND'), value.name='V', variable.name='STAT')
	#	melt the statistics on clades
	tmp			<- melt(stat.clades, measure.vars=c('READ_P_CLADE','AVG_ROOT2TIP_CLADE'), id.vars=c('PTY_RUN','W_FROM','W_TO','FILE','IND','ORDER_CLADE'), value.name='V', variable.name='STAT')
	set(tmp, NULL, 'STAT', tmp[,gsub('_CLADE','',STAT)])
	#	select most prevalent clades and put all together
	stat.plot	<- rbind( stat.plot, subset(tmp, ORDER_CLADE<=plot.max.clade), use.names=TRUE, fill=TRUE )
	#	give things nice names
	set(stat.plot, NULL, 'ORDER_CLADE', stat.plot[, as.character(ORDER_CLADE)])
	tmp			<- stat.plot[, which(!is.na(ORDER_CLADE))]
	set(stat.plot, tmp, 'ORDER_CLADE', stat.plot[tmp, paste('Clade',ORDER_CLADE)])
	tmp			<- stat.plot[, sort(na.omit(unique(ORDER_CLADE)))]
	set(stat.plot, stat.plot[, which(is.na(ORDER_CLADE))], 'ORDER_CLADE', 'Individual')
	set(stat.plot, NULL, 'ORDER_CLADE', stat.plot[, factor(ORDER_CLADE, levels=c('Individual',tmp), labels=c('Individual',tmp))])	
	set(stat.plot, NULL, 'STAT', stat.plot[,factor(STAT, levels=c('READ_N','UREAD_N','CLADE_N','READ_P','AVG_ROOT2TIP'), labels=c('Reads\n(#)', 'Tips\n(#)','Monophyletic\nclades\n(#)','Reads\n(%)','Root-to-tip\npatristic distance\n(mean subst/site)'))])
	#	
	#	setup plots per patient	
	#
	ps	<- lapply(stat.plot[, unique(IND)], function(x){
				#x<- 'R1_RES669_S20_L001'
				tmp			<- subset(stat.plot, IND==x)
				set(tmp, NULL, 'IND', tmp[,paste('run:',PTY_RUN,', individual:',IND)])
				col			<- c('black',rainbow_hcl(tmp[, length(unique(ORDER_CLADE))-1], start = 270, end = -30, c=100, l=50))
				names(col)	<- tmp[, unique(ORDER_CLADE)]	
				setkey(tmp, PTY_RUN, W_FROM, IND, ORDER_CLADE)
				p			<- ggplot(tmp , aes(x=W_FROM, y=V)) +
						geom_point(data=subset(tmp, !grepl('Reads\n(%)',STAT)), size=0.5, aes(colour=ORDER_CLADE)) +
						geom_bar(data=subset(tmp, STAT=='Reads\n(%)'), stat='identity', aes(fill=ORDER_CLADE)) +
						geom_line(data=subset(tmp, grepl('Root-to-tip',STAT)), aes(colour=ORDER_CLADE, group=ORDER_CLADE)) +
						scale_colour_manual(values=col) +
						scale_fill_manual(values=col, guide=FALSE) +
						scale_x_continuous(breaks=seq(0,12e3,1e3), minor_breaks=seq(0,12e3,2e2), expand=c(0,0), lim=c(1,stat.plot[, max(W_TO)+1])) +
						theme_bw() + labs(x='Genome location', y='', colour='', fill='') +
						facet_grid(STAT~IND, scale='free_y')				
			})
	cat('\nPlot to',outfile)
	pdf(file=outfile, w=9, h=9)			
	for(p in ps)
		print(p)					
	dev.off()	
}
###############################################################################
#	run script
###############################################################################
#
#	find all pre-processed tree files (FILE)
infiles		<- data.table(FILE=list.files(indir, pattern='preprtr.rda$'))
#	reconstruct the phylotype run ID (PTY_RUN)
#	(useful to store output by phylotype run)
if(nchar(run.pattern))
	infiles[, PTY_RUN:= as.numeric(gsub(run.pattern,'',sapply(strsplit(FILE,'_'),'[[',1)))]
if(!nchar(run.pattern))
	infiles[, PTY_RUN:= 1L]
setkey(infiles, PTY_RUN)
#	process only the selected files
#	(useful to run this in parallelel)
infiles		<- subset(infiles, grepl(select, FILE))
#	now loop over all selected files
for(i in seq_len(nrow(infiles)))		
{
	cat('\nprocess',infiles[i,FILE])
	file		<- file.path(indir,infiles[i,FILE])
	# load the pre-processed objects "pty.ph"   "ptyfiles"
	# pty.ph 	is a named list of rooted phylogenies in ape format, with max pars state reconstruction
	#			the name refers to the original file name
	# ptyfiles 	is a data.table that maps the original file name to phylotype run and window coordinates 
	load( file )	
	#
	# run the latest version to calculate the scan statistics
	#
	#pty.stat	<- pty.stat.all.160128(pty.ph, ptyfiles)
	tmp			<- pty.stat.superinfections.160208(pty.ph, ptyfiles, references.pattern=references.pattern)
	stat.ind	<- tmp$stat.ind
	stat.clades	<- tmp$stat.clades
	#	save to file
	file		<- file.path(outdir, basename(gsub('preprtr\\.rda','stat\\.rda',file)))
	cat('\nsave to file',file)
	save(stat.ind, stat.clades, pty.ph, ptyfiles, file=file)		
	cat('\nwrite "stat.ind" to file',gsub('\\.rda','_ind.csv',file))
	write.csv( subset(stat.ind, select=setdiff(colnames(stat.ind),'FILE')), row.names=FALSE, file=gsub('\\.rda','_ind.csv',file) )
	cat('\nwrite "stat.clades" to file',gsub('\\.rda','_clades.csv',file))
	write.csv( subset(stat.clades, select=setdiff(colnames(stat.clades),'FILE')), row.names=FALSE, file=gsub('\\.rda','_clades.csv',file) )
	#
	#	plot to file
	#	this must be bumped to the latest version that is compatible with the calculated scan statistics 
	if(!is.na(plot.max.clade) & plot.max.clade>0)
	{
		file		<- gsub('\\.rda','\\.pdf',file)
		cat('\nplot to file',file)
		pty.stat.superinfections.160208.plot(stat.clades, stat.ind, file, plot.max.clade=plot.max.clade)	
	}		
	gc()
}

