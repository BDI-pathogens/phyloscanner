args <- commandArgs()
if(!any(args=='--args'))
	args<- vector("numeric",0)
if(any(args=='--args'))
	args<- args[-(1:match("--args", args)) ]
#	default args
indir					<- NA
outdir					<- NA
select					<- ''
references.pattern		<- 'REF'
run.pattern				<- 'ptyr'
plot.max.clade			<- 0

if(exists("args"))
{	
	tmp<- na.omit(sapply(args,function(arg)
					{	switch(substr(arg,2,6),
								indir= return(substr(arg,8,nchar(arg))),NA)	}))
	if(length(tmp)>0) indir<- tmp[1]	
	tmp<- na.omit(sapply(args,function(arg)
					{	switch(substr(arg,2,7),
								outdir= return(substr(arg,9,nchar(arg))),NA)	}))
	if(length(tmp)>0) outdir<- tmp[1]
	tmp<- na.omit(sapply(args,function(arg)
					{	switch(substr(arg,2,7),
								select= return(substr(arg,9,nchar(arg))),NA)	}))
	if(length(tmp)>0) select<- tmp[1]
	tmp<- na.omit(sapply(args,function(arg)
					{	switch(substr(arg,2,15),
								plot.max.clade= return(as.numeric(substr(arg,17,nchar(arg)))),NA)	}))
	if(length(tmp)>0) plot.max.clade<- tmp[1]		
	tmp<- na.omit(sapply(args,function(arg)
					{	switch(substr(arg,2,19),
								references.pattern= return(substr(arg,21,nchar(arg))),NA)	}))
	if(length(tmp)>0) references.pattern<- tmp[1]
	tmp<- na.omit(sapply(args,function(arg)
					{	switch(substr(arg,2,12),
								run.pattern= return(substr(arg,14,nchar(arg))),NA)	}))
	if(length(tmp)>0) run.pattern<- tmp[1]			
}
if( is.na(indir) )
{
	cat('\nusage: Rscript phyloscan.scan.superinfections.Rscript -indir=INDIR
\t\t\t[-outdir=OUTDIR] [-select=SELECT] [-references.pattern=REFPATTERN]
\t\t\t[-run.pattern=RUNPATTERN] [-plot.max.clade=PMAXCLADE]
\nThis R script scans short read trees for phylogenetic evidence of super-infections. 
\t\t\tShort read trees must have been pre-processed with "phyloscan.evaluate.examl.Rscript"
\t\t\tand stored in an R object file ending in "_preprtr.rda". The script reads these files from
\t\t\tdirectory INDIR and calculates several tree statistics. Tree statistics are stored in
\t\t\tcorresponding R object files ending in "_stat.rda", as well as several ".csv" files. 
\t\t\tIf PMAXCLADE is set to a value >1, scan statistics for each individual are plotted to a 
\t\t\tcorresponding pdf file.
\nR users can use the functions "pty.stat.superinfections.XXX" and "pty.stat.superinfections.XXX.plot" directly.    
\narguments:\n
\t-indir=INDIR: Input directory with pre-processed short read trees in files ending with "_examl.rda".
\noptional arguments:\n
\t-outdir=OUTDIR: Output directory. By default set to INDIR.
\t-references.pattern=REFPATTERN: Regular expression that identifies all reference 
\t\t\tsequences. By default "REF".
\t-run.pattern=RUNPATTERN: String that identifies files of separate phylotype runs. 
\t\t\tThe string must be followed by a number. Output is produced for each run separately.
\t\t\tThis option is useful to group output as desired. Without the SELECT option, all 
\t\t\tgroups will be processed sequentially. By default ""; could e.g. be "^ptyr" to 
\t\t\tgroup newick files starting with "ptyr1_" and "ptyr2_" into two separate runs 
\t\t\t"1" and "2".
\t-select=SELECT: Regular expression that selects a subset of newick files in the 
\t\t\tinput directory. This is useful to avoid very large file sizes and memory consumption 
\t\t\tof this Rscript. Also useful to parallelize this processing step. By default ""; 
\t\t\tcould e.g. be "^ptyr22_".
\t-plot.max.clade=PMAXCLADE: Plot scan statistics for the largest PMAXCLADE monophyletic 
\t\t\tclades of every individual in each window. By default 0.
')
	quit('no')
}
if( is.na(outdir) )
	outdir	<- indir
if(1)
{ 
	print(indir) 
	print(outdir) 
	print(select) 
	print(references.pattern)
	print(run.pattern)
	print(plot.max.clade)
}
###############################################################################
#	standalone: load packages
###############################################################################
require(ape)
require(phytools)
require(phangorn)
require(reshape2)
require(data.table)
require(RColorBrewer)
require(colorspace)
require(grid)
require(gridExtra)
require(ggplot2)
require(ggtree)
require(zoo)
###############################################################################
#	standalone: define functions
###############################################################################
pty.stat.avgnodedepth.and.counts<- function(ph, mrca, select=NA)
{
	if(mrca<=Ntip(ph))
	{
		phb		<- data.table(	BAM=ph$tip.label[mrca],
				IND=gsub('_read.*','',ph$tip.label[mrca]),
				COUNT=as.numeric(gsub('count_','',regmatches(ph$tip.label[mrca], regexpr('count_[0-9]+',ph$tip.label[mrca])))),											
				DEPTH=0	)
	}
	if(mrca>Ntip(ph))
	{
		ph		<- extract.clade(ph,mrca)
		phb		<- data.table(	BAM=ph$tip.label,
				IND=gsub('_read.*','',ph$tip.label),
				COUNT= as.numeric(gsub('count_','',regmatches(ph$tip.label, regexpr('count_[0-9]+',ph$tip.label))))	)
		phb[, DEPTH:=node.depth.edgelength(ph)[seq_len(Ntip(ph))]]
	}		
	if(!is.na(select))
		phb		<- subset(phb, grepl(select,IND))
	list(AVG_ROOT2TIP=phb[, sum(DEPTH*COUNT) / sum(COUNT)], READ_N=phb[, sum(COUNT)], UREAD_N=phb[, length(COUNT)])	
}
pty.stat.monophyletic.clades<- function(ph)
{
	phb			<- data.table(IDX=seq_along(ph$tip.label), BAM=ph$tip.label, IND= gsub('_read.*','',ph$tip.label), REF=grepl(references.pattern,ph$tip.label))
	set(phb, phb[, which(REF)],'IND','REFERENCE')
	#	for each patient define mrca (MRCA)
	#	for each patient, 
	#		determine MRCA (mrca)
	#		calculate number of other individuals in clade below MRCA (diff)	
	z			<- phb[, {
				#print(GROUP)
				mrca	<- IDX		
				diff	<- 0L
				if(length(IDX)>1)
				{
					mrca	<- as.integer(getMRCA(ph, IDX))
					tmp		<- extract.clade(ph, mrca, root.edge=1)
					#print(tmp)
					diff	<- length(setdiff(gsub('_read.*','',tmp$tip.label), IND))								
				}												
				list(MRCA=mrca, DIFF_IND=diff)							
			}, by=c('IND')]	
	z			<- subset(z, IND!='REFERENCE')
	#	for all patients that are not monophyletic, there could be several clades
	#		trace back all ancestors between tips of other individuals and MRCA
	#		for each such tip, construct the unique path to MRCA that is not on a previous path
	#		find change points on these unique paths below which the subtree contains reads from the current patient
	#		the idea is that all monophyletic clades of this patient must break off from one of these paths	
	tmp			<- subset(z, DIFF_IND>0, c(IND, MRCA))
	if(nrow(tmp))
	{
		#	find all tips that belong to another patient than the current individual
		tmp			<- tmp[, {
					if(MRCA<=Ntip(ph))
						tmp	<- ph$tip.label[MRCA]
					if(MRCA>Ntip(ph))
						tmp	<- extract.clade(ph,MRCA)$tip.label
					list(MRCA=MRCA, MRCA_IND=IND, BAM=tmp)	
				}, by='IND']
		tmp[, IND:=NULL]
		zz			<- merge(tmp, subset(phb, select=c(BAM, IND, IDX)), by='BAM')
		zz			<- subset(zz, MRCA_IND!=IND)
		#	determine change points
		zz			<- zz[, {
					#IDX<- c(980,910,912,950); MRCA<- 1580; IND<- 'R1_RES669_S20_L001'; MRCA_IND<- 'R1_RES827_S23_L001'					
					#	determine paths to MRCA from each tip
					anc.group		<- Ancestors(ph, IDX)	
					if(!is.list(anc.group))
						anc.group	<- list(anc.group)
					anc.group	<- lapply(seq_along(anc.group), function(i)  anc.group[[i]][ seq_len(which(anc.group[[i]]==MRCA[1])-1)] )							
					#	determine unique paths until we hit a path that is already visited
					anc.join	<- lapply(seq_along(anc.group), function(i){	unique(unlist(lapply(seq_len(i), function(j) anc.group[[j]])))	})
					anc.join	<- c(NA,anc.join)
					anc.group	<- lapply(seq_along(anc.group), function(i)	setdiff(anc.group[[i]],anc.join[[i]])	)
					#	check which clades defined by the mrcas on the ancestor path contain at least one read from MRCA_IND
					tmp			<- lapply(seq_along(anc.group), function(i) sapply(anc.group[[i]], function(j)	any(grepl(MRCA_IND, extract.clade(ph,j)$tip.label))		)	)				
					#	determine lowest node (counting from tips) which contains at least one read from MRCA_IND
					tmp			<- lapply(seq_along(tmp), function(i){
								ans		<- NA_integer_	
								tmp2	<- integer(0)
								if(length(tmp[[i]]))
									tmp2<- which(tmp[[i]]) 
								if(length(tmp2))
									ans	<- as.integer(anc.group[[i]][tmp2[1]])										
								ans
							})				
					list(IDX=IDX, CHANGE_NODE=unlist(tmp))
				},by=c('IND','MRCA','MRCA_IND')]
		zz			<- subset(zz, !is.na(CHANGE_NODE))
		#	each ancestor before a change node could have as one of its children a monophyletic clade from this patient
		setkey(zz, MRCA_IND, CHANGE_NODE)
		zz	<- unique(zz)
		zz	<- zz[, {
					#CHANGE_NODE<- 2053; MRCA<- 1580; MRCA_IND<- 'R1_RES827_S23_L001'
					#MRCA<- 1212; MRCA_IND<- 'R1_RES669_S20_L001'; CHANGE_NODE<- 1218
					#	the first two potentially monophyletic clades are the children of the CHANGE_NODE
					tmp			<- Children(ph, CHANGE_NODE)					
					#	define path from change node to just before mrca 					
					path		<- c(CHANGE_NODE, setdiff( Ancestors(ph,CHANGE_NODE), c(MRCA,Ancestors(ph,MRCA)) ))
					#	monophyletic clades could break off the path ending at MRCA
					#	the mrca's of these clades are the siblings of the path constructed above 
					pot.clade	<- c(tmp, unlist(Siblings(ph, path)))
					#	check if potential clades are monophyletic
					tmp			<- sapply(pot.clade, function(x){
								if(x<=Ntip(ph))
									ans	<- grepl(MRCA_IND, ph$tip.label[x])
								if(x>Ntip(ph))
									ans	<- all(grepl(MRCA_IND, extract.clade(ph,x)$tip.label))
								ans
							})	
					#	return monophyletic clades
					list(CLADE=as.integer(pot.clade[tmp]))
				}, by=c('MRCA_IND','CHANGE_NODE')]
		zz[, CHANGE_NODE:=NULL]
		setnames(zz,'MRCA_IND','IND')
		#	merge all monophyletic clades
		z	<- merge(z, unique(zz), all=1, by='IND', allow.cartesian=TRUE)
	}	
	tmp	<- z[, which(DIFF_IND==0)]
	set(z, tmp, 'CLADE', z[tmp,MRCA])
	#	double check CLADEs (the MONOPH_PA condition is key)
	tmp	<- z[,{
				if(CLADE<=Ntip(ph))
					tmp	<- grepl(IND, ph$tip.label[CLADE])
				if(CLADE>Ntip(ph))
					tmp	<- all(grepl(IND, extract.clade(ph,CLADE)$tip.label))
				list(MONOPH=tmp, MONOPH_PA=all(grepl(IND, extract.clade(ph,Ancestors(ph, CLADE, type="parent"))$tip.label)))
			}, by=c('IND','CLADE')]
	stopifnot(tmp[, all(MONOPH)], tmp[, !any(MONOPH_PA)])
	z	
}
pty.stat.superinfections.160208<- function(pty.ph, ptyfiles, references.pattern='REF')
{	
	#	@CF: with data.table, the df[, {}, by=BY] syntax specifies the columns BY to loop over
	#	@CF: the return variables of a data.table block {} are either a named list, or another data.table
	#	@CF: one difference to data.frame is that the column names are available as variable names inside the block {}
	
	#	For each phylotype run (PTY_RUN), each patient (IND), each window (W_FROM, W_TO):
	#	- find the root node (CLADE) defining all monophyletic clades		
	stat.clades	<- ptyfiles[, {
				#FILE		<- subset(ptyfiles, W_FROM==661)[,FILE]
				#FILE<- 'ptyr22_InWindow_481_to_540_dophy_examl.newick'
				cat('\n',FILE)
				ph			<- pty.ph[[FILE]]
				pty.stat.monophyletic.clades(ph)							
			}, by=c('PTY_RUN','W_FROM','W_TO','FILE')]
	gc()	
	#	For each monophyletic clade:
	#	- calculate the mean node root-to-tip within clade, weighted by read count
	#	- calculate the number of reads
	#	- calculate the number of unique reads
	tmp			<- stat.clades[, {
				#tmp<- subset(stat.clades, W_FROM==661); FILE<- tmp[,FILE]
				#FILE<- 'ptyr22_InWindow_661_to_720_dophy_examl.newick'; CLADE<- 2066
				#cat('\n',FILE)
				ph			<- pty.ph[[FILE]]
				tmp			<- pty.stat.avgnodedepth.and.counts(ph, CLADE, select=NA)	
				names(tmp)	<- paste(names(tmp),'_CLADE',sep='')				
				tmp
			}, by=c('PTY_RUN','W_FROM','W_TO','FILE','CLADE')]
	stat.clades	<- merge(stat.clades, tmp, by=c('PTY_RUN','W_FROM','W_TO','FILE','CLADE'))
	gc()	
	#	For each phylotype run (PTY_RUN), each patient (IND), each window (W_FROM, W_TO):
	#	- calculate the average root to tip distance, weighted by read count
	#	  this requires the MRCA which can be expensive but has already been computed
	#	- calculate the total number of reads 
	#	- calculate the number of unique reads
	setkey(stat.clades, PTY_RUN, W_FROM, W_TO, FILE, IND)
	tmp			<- subset(unique(stat.clades), select=c(PTY_RUN, W_FROM, W_TO, FILE, IND, MRCA))
	stat.ind	<- tmp[,{
				ph			<- pty.ph[[FILE]]
				pty.stat.avgnodedepth.and.counts(ph, MRCA, select=IND)				
			}, by=c('PTY_RUN','W_FROM','W_TO','FILE','IND')]
	set(stat.ind, NULL, 'UREAD_N', stat.ind[, as.numeric(UREAD_N)])
	#	For each phylotype run (PTY_RUN), each patient (IND), each window (W_FROM, W_TO):
	#	- calculate number of clades
	tmp			<- stat.clades[, list(CLADE_N=as.numeric(length(CLADE))), by=c('PTY_RUN','W_FROM','W_TO','FILE','IND')]	
	stat.ind	<- merge(stat.ind, tmp, by=c('PTY_RUN','W_FROM','W_TO','FILE','IND'))
	#	For each monophyletic clade:
	#	- calculate the proportion of reads in the clade
	#	- calculate clade order by proportion
	stat.clades	<- merge(stat.clades, subset(stat.ind, select=c(PTY_RUN, W_FROM, W_TO, FILE, IND, READ_N)), by=c('PTY_RUN','W_FROM','W_TO','FILE','IND'))	
	stat.clades[, READ_P_CLADE:= READ_N_CLADE/READ_N]
	stat.clades[, READ_N:= NULL]
	stat.clades	<- stat.clades[ order(PTY_RUN, W_FROM, W_TO, FILE, IND, -READ_P_CLADE), ]	
	tmp			<- stat.clades[, list(ORDER_CLADE= seq_along(CLADE), CLADE=CLADE), by=c('PTY_RUN','W_FROM','W_TO','FILE','IND')]
	stat.clades	<- merge(stat.clades, tmp, by=c('PTY_RUN','W_FROM','W_TO','FILE','IND','CLADE'))
	#
	#	check that all reads are in one clade
	#
	tmp			<- stat.clades[, list(READ_N_CHECK=sum(READ_N_CLADE)), by=c('PTY_RUN','W_FROM','W_TO','FILE','IND')]	
	tmp			<- merge(tmp, subset(stat.ind, select=c(PTY_RUN, W_FROM, W_TO, FILE, IND, READ_N)), by=c('PTY_RUN','W_FROM','W_TO','FILE','IND'))
	stopifnot( !nrow(subset(tmp, READ_N_CHECK<READ_N))	)
	list(stat.clades=stat.clades, stat.ind=stat.ind)
}
pty.stat.superinfections.160208.plot<- function(stat.clades, stat.ind, outfile, plot.max.clade=5)
{			
	#
	#	print by patient
	#
	
	#	@CF: To get a sub-plot for each statistic using 'facet_grid', I melt the data.table
	#	@CF: the 'set' command looks a bit weird, but is great because it avoids creating new R objects via '<-'
	
	#	melt the statistics on individuals
	stat.plot	<- melt(stat.ind, measure.vars=c('READ_N','UREAD_N','CLADE_N','AVG_ROOT2TIP'), id.vars=c('PTY_RUN','W_FROM','W_TO','FILE','IND'), value.name='V', variable.name='STAT')
	#	melt the statistics on clades
	tmp			<- melt(stat.clades, measure.vars=c('READ_P_CLADE','AVG_ROOT2TIP_CLADE'), id.vars=c('PTY_RUN','W_FROM','W_TO','FILE','IND','ORDER_CLADE'), value.name='V', variable.name='STAT')
	set(tmp, NULL, 'STAT', tmp[,gsub('_CLADE','',STAT)])
	#	select most prevalent clades and put all together
	stat.plot	<- rbind( stat.plot, subset(tmp, ORDER_CLADE<=plot.max.clade), use.names=TRUE, fill=TRUE )
	#	give things nice names
	set(stat.plot, NULL, 'ORDER_CLADE', stat.plot[, as.character(ORDER_CLADE)])
	tmp			<- stat.plot[, which(!is.na(ORDER_CLADE))]
	set(stat.plot, tmp, 'ORDER_CLADE', stat.plot[tmp, paste('Clade',ORDER_CLADE)])
	tmp			<- stat.plot[, sort(na.omit(unique(ORDER_CLADE)))]
	set(stat.plot, stat.plot[, which(is.na(ORDER_CLADE))], 'ORDER_CLADE', 'Individual')
	set(stat.plot, NULL, 'ORDER_CLADE', stat.plot[, factor(ORDER_CLADE, levels=c('Individual',tmp), labels=c('Individual',tmp))])	
	set(stat.plot, NULL, 'STAT', stat.plot[,factor(STAT, levels=c('READ_N','UREAD_N','CLADE_N','READ_P','AVG_ROOT2TIP'), labels=c('Reads\n(#)', 'Tips\n(#)','Monophyletic\nclades\n(#)','Reads\n(%)','Root-to-tip\npatristic distance\n(mean subst/site)'))])
	#	
	#	setup plots per patient	
	#
	ps	<- lapply(stat.plot[, unique(IND)], function(x){
				#x<- 'R1_RES669_S20_L001'
				tmp			<- subset(stat.plot, IND==x)
				set(tmp, NULL, 'IND', tmp[,paste('run:',PTY_RUN,', individual:',IND)])
				col			<- c('black',rainbow_hcl(tmp[, length(unique(ORDER_CLADE))-1], start = 270, end = -30, c=100, l=50))
				names(col)	<- tmp[, unique(ORDER_CLADE)]	
				setkey(tmp, PTY_RUN, W_FROM, IND, ORDER_CLADE)
				p			<- ggplot(tmp , aes(x=W_FROM, y=V)) +
						geom_point(data=subset(tmp, !grepl('Reads\n(%)',STAT)), size=0.5, aes(colour=ORDER_CLADE)) +
						geom_bar(data=subset(tmp, STAT=='Reads\n(%)'), stat='identity', aes(fill=ORDER_CLADE)) +
						geom_line(data=subset(tmp, grepl('Root-to-tip',STAT)), aes(colour=ORDER_CLADE, group=ORDER_CLADE)) +
						scale_colour_manual(values=col) +
						scale_fill_manual(values=col, guide=FALSE) +
						scale_x_continuous(breaks=seq(0,12e3,1e3), minor_breaks=seq(0,12e3,2e2), expand=c(0,0), lim=c(1,stat.plot[, max(W_TO)+1])) +
						theme_bw() + labs(x='Genome location', y='', colour='', fill='') +
						facet_grid(STAT~IND, scale='free_y')				
			})
	cat('\nPlot to',outfile)
	pdf(file=outfile, w=9, h=9)			
	for(p in ps)
		print(p)					
	dev.off()	
}
###############################################################################
#	run script
###############################################################################
infiles		<- data.table(FILE=list.files(indir, pattern='preprtr.rda$'))
if(nchar(run.pattern))
	infiles[, PTY_RUN:= as.numeric(gsub(run.pattern,'',sapply(strsplit(FILE,'_'),'[[',1)))]
if(!nchar(run.pattern))
	infiles[, PTY_RUN:= 1L]
setkey(infiles, PTY_RUN)
infiles		<- subset(infiles, grepl(select, FILE))

for(i in seq_len(nrow(infiles)))		
{
		cat('\nprocess',infiles[i,FILE])
		file		<- file.path(indir,infiles[i,FILE])
		load( file )	#loads "pty.ph"   "ptyfiles"		
		#pty.stat	<- pty.stat.all.160128(pty.ph, ptyfiles)
		tmp			<- pty.stat.superinfections.160208(pty.ph, ptyfiles, references.pattern=references.pattern)
		stat.ind	<- tmp$stat.ind
		stat.clades	<- tmp$stat.clades
		#	save to file
		file		<- file.path(outdir, basename(gsub('preprtr\\.rda','stat\\.rda',file)))
		cat('\nsave to file',file)
		save(stat.ind, stat.clades, pty.ph, ptyfiles, file=file)		
		cat('\nwrite "stat.ind" to file',gsub('\\.rda','_ind.csv',file))
		write.csv( subset(stat.ind, select=setdiff(colnames(stat.ind),'FILE')), row.names=FALSE, file=gsub('\\.rda','_ind.csv',file) )
		cat('\nwrite "stat.clades" to file',gsub('\\.rda','_clades.csv',file))
		write.csv( subset(stat.clades, select=setdiff(colnames(stat.clades),'FILE')), row.names=FALSE, file=gsub('\\.rda','_clades.csv',file) )
		#	plot to file
		if(!is.na(plot.max.clade) & plot.max.clade>0)
		{
			file		<- gsub('\\.rda','\\.pdf',file)
			cat('\nplot to file',file)
			pty.stat.superinfections.160208.plot(stat.clades, stat.ind, file, plot.max.clade=plot.max.clade)	
		}		
		gc()
}

